---
title: "UNSW Course Review"
description: "Review on courses I've taken at UNSW"
date: "2022-05-17"
---

# Context

I've been asked pretty often about what courses to take at UNSW, and guides on how to do well so hopefully this page will help.

Before UNSW, I had an interest in engineering (leaning towards Electrical Engineering), though I also wanted to do a double degree with Commerce since I found economics interesting.
So I picked a double degree in Computer Science / Commerce as the degree was 4 years rather than the 5.6 years of Engineering / Commerce, despite having 0 programming experience (though I dropped Commerce after taking 1 Commerce course).

---

# 20T1

## COMP1511 - Programming Fundamentals

_C, if … else, while, arrays, pointers, structs, linked lists_

### Overview

The starter programming course.
You’ll have 2 lectures, 1 tut-lab each week (where you have a 1 hr tutorial where you listen to your tutor present topics, and 2 hr lab where you code and can ask for help).
The course tends to get a bit more confusing when pointers are introduced.
Whilst the skills taught in this course (i.e. if else, and while loops) are easily transferable to other languages, you are mostly taught “programming” which is a tool, but not necessarily the “science” of computer science (more theory), or the “engineering” of software engineering (how to write good quality, useful code that can adapt to new requirements).

**Do I need to know programming beforehand?**

I had next to 0 programming coming into the course, and the course is designed such that someone with no experience can learn everything so, it’s very possible to HD the course without prior experience.

**Why do we learn C?**

Admittedly, C is not the most practical language (you can easily build an app or website using it), despite this, in my opinion there’s good reason to learn it first.

- It’s a low level language (compared to most others you will use), meaning you interact more with the underlying machine - so you learn a bit about computer memory
- Other beginner friendly languages (i.e. Python/JavaScript) has many abstractions/inbuilt functions, whereas in C you have to code it yourself, which forces you to think about how things work.

**What if I've done programming before?**

There are many fantastic challenge problems in the course - give a shot at those.
The final exam, and to a small degree the assignments have an exponential difficulty, so even those with experience may struggle with some of the problems.
I thoroughly enjoyed the challenges, and found them to motivate me to study CS more, though it may not be everyone’s cup of tea, or that practical/useful.

## MATH1131 - Mathematics 1A

_Linear algebra (complex numbers, vectors, linear equations, matrices), calculus (limits, continuity, integration, logarithms, exponentials, hyperbolic functions)_

### Overview

Goes over linear algebra and calculus.
In my opinion, the calculus part started of pretty dry as it was focused a lot on the definition of a limit, etc. I originally was doing 1141, but dropped it after a couple of weeks due to terrible time management and me adapting from high school to uni + work.
It's pretty normal to get close to full marks for your pre exam mark and lost most your marks in the final exam.

**Will I struggle in this course if I haven't done 3U or 4U?**

You'll have to put in more effort, but it's 100% not impossible to do very well.
It's not unheard of for students to not do 4U, but do well in 1131, and then even pick up 1241.

**Should I do this or MATH1241?**

From what I know MATH1241 requires you to do / submit assignments earlier, and go more into mathematical proofs.
However, for most people doing CS, I'd argue the extra content in 1241 will not be relevant.
So if you want to do more math, feel free to do 1241.

**Recommended resources**

- Get the online textbook for the course from moodle (I found this more useful than the lectures)

## ECON1101 - Microeconomics 1

_Microeconomics idk man_

### Overview

Quite a fun course, where you're required to complete a mid sem, play a game called Playconomics and a final exam.
Alberto's lecturers were great fun, and the first lecture was a bit like a comedy night live (until covid hit and things were online).

Overall, the course is a good introduction to Economics (though nothing you can't learn from casually watching Youtube videos).
However, we had to pay $40 for the textbook + Playconomics.
I decided to drop commerce after this course since I didn't find the course as engaging and writing long answer responses / essays wasn't my thing.

**Is this course a WAM booster?**

To be fair it was pretty easy when I did it.
They created a giant database of questions, some of which would be in the final exam, so that students could revise the content.
However, in my exam, there was a lot of vague game theory questions (likely because the exam was online, so students had access to their answers they made before the exam) which were tricky.

**What is Playconomics?**

In the lectures, they mention a revolutionary award winning game, where students who played it got better marks. In reality, it was because the game tended to broken, and a free 20 marks.
According to Alberto, every time, some engineering students manage to find an exploit and form a engineering cartel, resulting in some oligarchy of the economy, disrupting the economies of other players.

**Recommended resources**

- Read the textbook that they give you

# 20T2

## COMP1521 - Computer System Fundamentals

_Bits & bytes, MIPs (assembly language), file systems, concurrency, virtual memory_

### Overview

A course where you learn about low level bits & bytes, the MIPs assembly language, and file systems. This was my least favourite 1st year course, as the content was pretty dry.

Overall, the content from this course wasn't too immediately useful unless you intend to go more into low level content, i.e. embedded systems / operating systems, so you can hold this course off (which tends to be alright for dual degrees).

You'll find the content in this course is a bit of a jump from COMP1511 - the content after file systems was introduced was all a bit of a blur and quite high level.
Though if you are interested in those topics, take Operating Systems.

**Is this more difficult than COMP2521?**

I'd say this course is around the same level of difficulty of COMP2521.
You may find that this course is more "content" heavy, whilst 2521 is more "theory" heavy.
The 1521 challenges are quite tougher than that of 1511, and if Andrew Taylor is in charge, the later questions of the exam will be exponentially harder than the earlier ones.

**Should I take this course or COMP2521 first?**

Most computer science students probably take both courses in T2 simultaneously, though if you had to choose, take 2521 first as it is a prerequisite to many comp courses.

## COMP2521 - Data Structures and Algorithms

_Big O, BST (Binary Search Trees), balanced BSTs, graphs & graph algos, hashing, heaps_

### Overview

My favourite 1st year comp course.
The course begins off with a recap on linked lists, so you may benefit from just having done COMP1511 (though not necessarily).
From there, it's a mix of implementing data structures & algorithms in C and some theory (though nothing too complex / much math involved).

**Why is the content in this course important?**

Whilst the content wouldn't help you build a cool practical application anytime soon, there are two reasons I suggest completing this course.

1. You learn how to quantitatively assess code quality (i.e. how efficient is your code)
2. The content here is relevant for most software engineering technical interviews
3. Some of the algorithms, i.e. BFS, DFS can still be useful in software engineering

Aside from that, you'll be more than fine without having to remember the quirks of a red-black tree or 2-3-4 trees.

**Recommended resources**

- [Back To Back SWE](https://www.youtube.com/channel/UCmJz2DV1a3yfgrR7GqRtUUA)

## MATH1231 - Mathematics 1B

_Linear algebra (vector spaces, matrices, linear transformation, eigenvalues & eigenvectors), calculus(differential equations, sequences, series, integration)_

### Overview

More on Linear Algebra and Calculus.
I found the matrices content to be quite interesting (which has some applications here and there in computer science).
Meanwhile the calculus gets more interesting compared to 11[34]1.

**Recommended resources**

- Get the online textbook for the course from moodle (I found this more useful than the lectures)

# 20T3

## COMP1531 - Software Engineering Fundamentals

_Python, Git, Flask, HTTP, testing, agile_

### Overview

A useful group work course where you learn Python, Flask, and Git - also usually the first course you make something more interesting than a command line app.

Most people will be able to pick up Python in the first few weeks, and the course for most students is mostly focused on the project.
The course tries to cover many different topics (i.e. Object Orientated Programming, software engineering practices like agile, testing, networks) briefly so make sure to properly revise that for the exam, as those concepts are not well covered by the project.

**Should I find good teammates before I start this course?**

When I did it it was 5 people per course, but the project is very doable with 4, and can be done by even less.
As a result, I wouldn't classify this as "necessary to find a good teammate" beforehand (unlike COMP2511).
I had one friend going into the course, and found new friends through the project.

**What should I do to prepare for this course?**

If you are keen to get ahead, there isn't much needed but here are some ideas.

- Set up your computer for local development! You can do 90% of the course work on your own computer (there isn't anything like autotests / give).
  - If you are on a unix based OS, you don't need to do much, else if you are on windows, I recommend setting up WSL.
  - Whilst you are at it I would recommend learning how to use virtual environments. A good explanation of how / why you should use them can be found [here](https://uoa-eresearch.github.io/eresearch-cookbook/recipe/2014/11/26/python-virtual-env/).
- Learn features of python such as dictionaries, and how to write "pythonic" code (i.e. short code that takes advantage of python's features)


## COMP3311 - Database Systems

_Database Schemas, SQL PlpgSQL, psycopg, normalisation, relational algebra, concurrency_

### Overview

In my opinion, the best first year comp elective if you're looking at backend development / data stuff, as it's not super content heavy, and still practical / engaging.
You'll work with PostgreSQL (a relational database), and it's Python module.

Overall the course structure looks a bit like:

1. Database diagrams & relational schema
2. SQL queries & PL/pgSQL
3. Working with SQL in Python
4. Theory (i.e. relational algebra, concurrency, ACID)

There were 3 assignments, and the last two were quite fun, and required a bit of thinking (and I've heard that in 21T1, they required a bit of BFS / DFS). The assignments were as follows.

1. Writing a database schema
2. Writing queries to extract data from a database (using SQL & PL/pgSQL)
3. Using python and psycopg to perform queries and extract data from a database

In order of importance for the topics, I'd say 2 > 3 > 1 > 4 (I low-key learnt the theory content in the middle of my online exam and I suspect most of the cohort was the same).

**Should I do this course in first year?**

Yep! I would highly recommend this as an early course elective because it's simple but also useful.
The only prerequisite is COMP2521, and I found the content to be a good balance of practical & theory (and it was pretty fun writing efficient queries).

## MATH1081 - Discrete Mathematics

_Set theory, number theory, logic, counting techniques, graph theory_

### Overview

Different to the typical math you're used to.

**Is discrete math more useful for computer science?**
The proofs that you complete in this course will be relevant for proofs in courses such as COMP3[18]21.
The perms & combs are somewhat relevant for certain algorithms that brute force permutations / combinations.
As for the graph theory, 2521 also goes over Dijkstra's but in more depth, doing either course first just helps you a bit in the other when it comes to graph theory.

# 21T1

## COMP3231 - Operating Systems

_Concurrency, file systems, virtual memory_

### Overview

An alright course in my opinion which covers the last couple topics of 1521, but in way more depth. There are 3 main assignments on different topics, the latter 2 of which are a bit heavier workload.

1. Concurrency (Individual work)
2. System calls / File systems (Pair work)
3. Virtual memory (Pair work)

Overall I found the first topic to be the most interesting and useful (learning about locks, semaphores, mutexes, CVs, etc), which was sad since they spent much more time on the following topics (which I didn't find useful).

The assignments tend to be more figuring out what you have to do than coding.
I ended up doing all assignments solo and found the workload to be alright.

**Recommended resources**

- [Virtual memory lectures](https://www.youtube.com/watch?v=qcBIvnQt0Bw&list=PLiwt1iVUib9s2Uo5BeYmwkDFUh70fJPxX)

## COMP3821 - Extended Algorithms and Programming Techniques

_Divide & conquer, greedy, dynamic programming, max flow, linear programming, reductions_

### Overview

There are only lectures (no tuts / labs), and also 0 programming as everything is written in the form of pseudo code or an english description of an algorithm with some proofs.
Specifically I had 4 assignments (each containing 5 questions to solve), and 4 group assignments.
In T1, I still spent more time on this course than OS (maybe because I found this more interesting).
You'll need some math knowledge such as matrices, complex numbers, and some proof writing, but they should all be covered in the 1st year math courses.

**Should I take this or the non extended version?**

Being the advanced version of COMP3121, I would only really recommend this course if you are willing to self study algorithms a bit more, and keen on learning reductions in a more formal way.
Some people may decide to take this course since it is in T1 (whereas COMP3121 is T2 & T3) and may teach algorithms required for intern / grad technical interviews.
From experience, this wasn't the case too much and the only time I 'applied' knowledge in this course was with some trading companies' technical interviews.
If I had to choose again I would still take COMP3821 > COMP3121, despite losing marks in the reduction topics.

**Recommended resources**

- Not a resource, but please go over all the tutorial problems before the assignments.
- [MIT lectures on algorithms](https://www.youtube.com/watch?v=HtSuA80QTyo&list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb)
- [Leetcode](https://leetcode.com/problemset/all/) (I found this to pretty useful for dynamic programming)

# 21T2

## COMP2511 - Object-Orientated Design & Programming

_Java, design patterns, code smells_

### Overview

A course that requires a LOT of coding.
Whilst in 2521, you learn to analyse code from a quantitative standpoint (i.e. time/space complexity), 2511 teaches you how to write high quality code from a qualitative standpoint (i.e. how to write non-spaghetti modular code that can change to adapt to requirements easily).

There is an (solo work) assignment and a group work project.
The assignment works as a good introduction to Java, whilst the project is quite a large project, which I feel is a necessary evil to teach the benefits of OOP, and software engineering practices.

**When should I do this course?**

In my opinion, I recommend completing this course perhaps as early as possible.
Learning Java and design principles is very valuable, for writing higher quality code, and internships that require Java/OOP.

**Should I find good teammates before I start this course?**

When I did the course, there were 4 members per group, all of which had to be in the same tut-lab class.
Unlike COMP1531, I would recommend finding teammates you can trust before you start the course due to the bigger project (which not only requires much more thinking about the design, but also coding().
It's still "doable" by 2 - 3 people, though highly draining, I had to spend 14+ hrs coding some days and had 2k+ lines of tests.

**Recommend resources**

- [Refactoring guru](https://refactoring.guru/)

## COMP3141 - Software System Design and Implementation

_Haskell, functional programming, induction, PBT, monads, type theory, curry-howard correspondence_

### Overview

Starts off by going through Haskell, which can be tricky and it's definitely not like your typical coding.
The course jumps a bit in difficulty in week 7 when you go over "functors, applicatives, and monads", so I would recommend reading up on this topic in flex week.
It then goes a bit more into the application of types as static checking, before touching on more theory, i.e. Curry-Howard correspondence in week 10 (which I'm told is similar to COMP3161).

**Is this a software engineering course?**

You don't build a practical app or anything in this course, which you may expect from software engineering, so if you like building things this may not be as fun.
Similarly, whilst you have to think quite a bit for the assignments, the code of the is pretty trivia to implement in other languages and the difficulty comes down to the self imposed restriction of using Haskell, and stronger type checking (as a result, the assignment was a lot of trying different permutations of code until it compiled).
That being said, you go more into the theory of good code.

**Recommended resources**

- [Learn You a Haskell for Great Good!](http://learnyouahaskell.com/)

## COMP3331 - Computer Networks and Applications

_Network application layer, transport layer, network layer, link layer, wireless networks_

### Overview

This course heavily follows the textbook "Computer Networking: A Top-down Approach" for 10 week (for the most part).
This may be a personal bias, but the course does have a lot of dry content, and since the content is the same as the textbook, I only did this as it was as prerequisite for COMP9243 (Distributed Systems).
The content mostly requires ROTE learning, and the labs were pretty straightforward (though sometimes boring, they would consist of running commands in the terminal / reading wireshark data, and the later labs reminded me more of high school science lab reports).

**How is the assignment?**

I've heard historically the assignment was pretty easy, however for 21T2, it did require some thinking about data structures and multi-threading.
You can choose between C, Python, and Java to implement the assignment (I would recommend Python for the sake of getting it done easily / quickly, and also because there's more tutor support for the language if you ever do need to go to help sessions).

**Recommended resources**

- [Computer Networking: A Top-down Approach 7th Edition](https://www.ucg.ac.me/skladiste/blog_44233/objava_64433/fajlovi/Computer%20Networking%20_%20A%20Top%20Down%20Approach,%207th,%20converted.pdf)

# 21T3

## COMP4121 - Advanced Algorithms

_Modern Algorithms, Statistics, Linear Algebra_

### Overview

Probably my favourite course so far for the following reasons

1. You have to do a major project which is due at the end of term.
   There's no real constraints aside from the fact that it has to include some algorithm somewhere, and you have to have learnt something from it.
2. This course definitely goes over more practical algorithms and very interesting algorithms.
   A lot of the previous algorithms you may have learnt are more "discrete / combinatorial".
   However with the rise of data science / ML, a lot of algorithms are now also more "numerical" and rely on stats & linear algebra which is what this course goes through.

The course is 50% a major project and 50% a final exam.
For the major project, you can write an essay, implement and compare some algorithms, or discuss with Aleks what you want to do (mine is viewable [here](https://github.com/angary/simulated-annealing-tsp)).
It's probably also very valuable to go to the consultations and discuss what you would like to do.

Overall, I highly recommend this to anyone interested in algorithms.
The only only "downside" is that the content is viewable from the course website even if you don't do the course, and there isn't really any labs or tuts.
Hence you can more or less learn the content without doing this course.

**How difficult is the course?**

Comparing the course with COMP3[18]21, there's two big differences:

1. The math tends to have more of a focus on statistics and linear algebra.
2. The questions in the final exam aren't designed to trick you.

The content isn't "easy", i.e. we do go over some difficult proofs and content.
That being said, the way that the content is assessed is pretty chill.
For example, you won't be tested on coming up with some DP algorithm to solve a combinatorial problem.
It'll be moreso like what happens if I tweak an algorithm by doing X, or what is the probability of X happening for these inputs.

**What is the workload like?**

The course can be content heavy though the content is very interesting.
That being said, you're comfortable with math, many topics will be quite easy to grasp.
Since, the course is 50% major project, 50% final exam, you could hypothetically do the major project whenever (as it doesn't have to rely on course content), and then only pay attention to the course at the very end.
That being said, you do learn quite a lot of techniques from the content, which can maybe help you with your major project.

## COMP9517 - Computer Vision

_Image processing, Feature Representation, Pattern Recognition, Image Segmentation, Motion Tracking, Deep Learning_

### Overview

A course that goes through different algorithms and techniques used in the field of Computer Vision.
Overall the course is a bit more "researchy" compared to other CSE courses, and is more back heavy in workload once the group project begins.

In terms of assessable content, there are labs, a solo assignment, a big group project, and a final exam.
The group project involves applying Computer Vision techniques, then making a video about techniques used, with a discussion on its results + improvements
For the exam, we were given a 10 page research paper, and required to do a 2 page literature review, (discuss the methods used, and discuss if they were suitable or not, along with issues or potential improvements).

**Should I know machine learning beforehand?**

It helps if you know Convolutional Neural Networks (CNNs), as this comes up in the later half of the course.
Many modern computer vision problems use CNNs as they may provide better results than traditional methods, however, there isn't sufficient time in the course to properly "teach" you, and so it may require self study.
CNNs can also be used in the assignment and may give better results, but the assignment is marked on how well you understood your techniques and how you evaluated their success and selected an appropriate method.
The knowledge also helps with literature review in the final exam, however, it's not guaranteed as the paper will involve techniques related to CNNs.

# 22T1

## COMP9315 - Database Management System Implementation

_Storage, Selection, Joins, Query Processing, Optimisation, ACID Transactions_

### Overview

This course goes over the low level implementation of a database (PostgreSQL in particular), and you code up some (not all) parts of a database management system.
Overall, it's a fantastic course and will feel like OS (also goes through storage, and concurrency), but more algos focused.
There are two assignments, the first of which was related to implementing a new type in PGSQL (mix of C and SQL), and the second of which was to implement Multi-Attribute Linear Hashing in C.

If you liked the algorithms part of OS, you'll likely also enjoy this course.
Both these courses also go through concurrency.

**Recommended resources**

- [Use the index luke](https://use-the-index-luke.com/) (Interesting for learning about the impact of indexing on query performance)

## COMP9417 - Machine Learning and Data Mining

_Regression, Classification, Tree Learning, Kernel Methods, Ensemble Learning, Neural Learning, Unsupervised Learning, Learning Theory_

### Overview

A course that goes through different algorithms / methods in machine learning.
Overall, this course was a decent workload, with weekly problem sets (combination of math and coding), 2 homework sets (combination of math and coding in a report), and a group project.
The group project is done in groups of 4, and applying machine learning techniques to some problem, and writing a report on your techniques used.
However, the grading is mostly done on your report (AKA how well written it is) rather than the performance of your model.

**Should I do a math course beforehand?**

It'll certainly help with the labs, overall, however may be fine without doing any other math course aside from the cores.
Below are a list of topics and the math that they involve, though you definitely won't need to understand the math super indepth.

**Recommended resources**

- [StatQuest - Machine Learning](https://www.youtube.com/watch?v=Gv9_4yMHFhI&list=PLblh5JKOoLUICTaGLRoHQDuF_7q2GfuJF) (Youtube playlist that goes over the math fundamentals and theory in ML)

# 22T2

## ARTS1630 - Introductory Japanese A

_hiragana, katakana, (basic kanji), conversational Japanese_

The content of this course follows along the Genki textbook up to chapter 6.

Whilst most COMP courses you can learn online for free, in my opinion there's a lot of value in language courses as you get to interact with others who are also learning the language which isn't an experience you get solo learning.

Having close to 0 knowledge of Japanese beforehand I felt the pacing was good, with tests on dictation (listening to Japanese and writing the Japanese, and reading Japanese), mock interations, and a moodle exam (i.e. reading comprehension in Japanese + written essay on a topic), all of which helped a lot.

**Should I learn Japanese or another language?**

It's a good language to learn if you are already "interested in Japanese culture", however if you want to quickly learn a language you can use, it's probably best to stick to a language closer to English (i.e. it is much easier to remember Germanic / Romance language vocabularies as they are similar to English).
However, its differences makes it a very interesting language to learn for the sake of learning a language (i.e. you learn very "formulaically" the grammar structure which is different to English, which makes you "think" differently, and there's interesting stories to some of the kanji characters).

**Recommended resources**

- [Tofugu - Learn Hiragana](https://www.tofugu.com/japanese/learn-hiragana/)
- [Tofugu - Learn Katakana](https://www.tofugu.com/japanese/learn-katakana/)

## COMP6741 - Algorithms for Intractable Problems

_NP-completeness, Kernalisation, Paramterised Intractability, Branching Algorithms, Treewidth, Randomised Algorithms, Iterative Compression, Exponential time hypothesis, Heuristics and Local Search_

Hard course (for me), runs every 2 years, cohort of 15 very smart people when I did it. Beware.

I would've taken notes for this course but there was a lot of content, and a lot of "thinking" that goes on.

## COMP9444 - Neural Networks and Deep Learning

_Perceptrons, NN theory, CNNs, LSTMs, NLP, Deep Reinforcement Learning, Hopfield Network & Boltzmann Machine, Autoencoders, Generative Adversarial Networks_

Most practical and fun AI course because you can take in inputs like images, video, natural language and do whatever whacky thing you want to do.
Not super math heavy, as you mostly learn about different Neural Network architectures, and you use Pytorch to implement them.
Major group project where you make whatever using a NN and a final exam which was pretty easy.

Note that as a higher level course, the course admining can be a bit dodgy at times, and it is usually up to you to self teach.
If you feel like you are comfortable enough self teaching the content, then there may be no need to take the coursee, as the course doesn't feature anything that you can't teach yourself online with, and there was very little to no feedback in the entire course.

**Recommended resources**

- [Deep Learning Book (MIT)](https://www.deeplearningbook.org/)


# 22T3

## COMP3900 - Computer Science Project

_Agile, Project Management Techniques, Ethics_

A necesary course for your degree.
You build web app (note it has to be a web app that can run on CSE machines) in a group of 5.
The project you build can either be based off a list of ideas they give you or you can propose a new idea.

My recommendation would be to pick a project that everyone feels interestd in working on, and set a level of complexity everyone is comfortable on in your proposal (i.e. do not say you will propose feaure 'X' for the sake of an impressive proposal), as you get marked more on completing everything in your proposal than you do on overall technical complexity.
Hence, you choose to some degree how much workload you want to put into this course.

There are also lectures, but you only get assessed on your project proposal / project / project report, hence for the most part the lecture content can be ignored (it also tends to be quite wishy washy / already covered in previous courses, i.e. Git).

## COMP4920 - Professional Issues and Ethics in Information Technology

_Utilitarianism, Dentological Ethics, Virtue Ethics, AI Ethics, Meta Ethics_

Quite a philosophical course that takes a high level look at ethics in Computer Science.
As a result the content feels too detached and is non reflective of typical ethical decisions that you make as a software engineer for it to be practical.
However, the assessments - 50% essay assignment and 50% group work presentation does require you to fall back on essay writing skills and presentation skills which tbh was the main things I learnt from this course.

## COMP6991 - Solving Modern Programming Problems with Rust

_Types, Error Handling, Borrowing, Lifetimes, Docs & Testing, Polymorphism, Functions, Meta-Programming, Concurrency, Parallelism, Unsafes_

Quite a well run course (compared to other high level courses), that goes through different features  of the Rust language (i.e. types, borrowing, lifetimes) and how they solve existing issues.
The course admining was quite good, resulting in helpful labs, workshops and forum responses, resulting in a good community when taking the course.

It's not necessarily a Rust course, but the discussion of programming patterns are driven by the features of Rust.
Consequently, you learn content i.e. memory management related to COMP1521, or design in COMP251, which is tailored to safe systems programming.


**Recommended Resources**
- [The Rust Programming Language](https://doc.rust-lang.org/book/)
