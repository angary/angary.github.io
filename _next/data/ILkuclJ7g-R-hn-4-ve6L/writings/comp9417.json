{"pageProps":{"contents":"<h1 id=\"statistical-techniques-for-data-analysis\"><a href=\"#statistical-techniques-for-data-analysis\">Statistical Techniques for Data Analysis</a></h1>\n\n<p>Probability vs Statistics</p>\n<ul>\n<li><strong>Probability:</strong> reasons from populations to samples (deductive reasoning)</li>\n<li><strong>Statistics:</strong> reasons from samples to populations (inductive reasoning)</li>\n</ul>\n<p><strong>Sampling</strong> is a way to draw conclusions about the population without measuring the whole population.\nThe characteristics of an ideal sampling model include</p>\n<ul>\n<li>No systematic bias</li>\n<li>The chance of obtaining an unrepresentative sample can be calculated</li>\n<li>The chance of obtaining an unrepresentative sample decreases with the size of the sample</li>\n</ul>\n<h2 id=\"estimation\">Estimation</h2>\n<p>In statistics, estimation refers to the process by which one makes inferences about a population.</p>\n<h2 id=\"mean\">Mean</h2>\n<p>The arithmetic mean is $m = \\frac{1}{n}\\sum_{i=1}^n x_i$, where the observations are $x_1, x_2, ..., x_n$.\nIf $x_i$ occurs $f_i$ times, and we define relative frequencies as $p_i = \\frac{f_i}{n}$, then the mean is $m = \\sum_i x_i p_i$.\nTherefore the expected value of a discrete random variable $X$ is:</p>\n<p>$$E(X) = \\sum_i x_i P(X=x_i)$$</p>\n<h2 id=\"variance\">Variance</h2>\n<p>Variance measures how far a set of random numbers are spread out from their average value.\nStandard deviation (square root of variance) is estimated as:</p>\n<p>$$s = \\sqrt{\\frac{1}{n-1} \\sum_i (x_i - m)^2}$$</p>\n<p>We can write this in terms of expected values $E(X)$ as</p>\n<p>$$Var(x) = E((X - E(X))^2) = E(X^2) - [E(x)]^2$$</p>\n<p>Variance is the &quot;mean of squares minus the squares of means&quot;</p>\n<h2 id=\"covariance-and-correlation\">Covariance and Correlation</h2>\n<p><strong>Covariance</strong> is a measure of relationship between two random variables:</p>\n<p>$$cov(x,y) = \\frac{\\sum_i (x_i - \\bar{x})(y_i - \\bar{y})}{n-1} = \\frac{(\\sum_i x_i y_i) - n \\bar{x} \\bar{y}}{n-1}$$</p>\n<p><strong>Correlation</strong> is a measure to show how strongly a pair of random variables are related:</p>\n<p>$$r = \\frac{cov(x,y)}{\\sqrt{var(x)}\\sqrt{var(y)}}$$</p>\n<p>This is also called Pearson&#39;s correlation coefficient.</p>\n<ul>\n<li>The correlation coefficient is a number between $-1$ and $+1$ that shows whether a pair of variables $x$ and $y$ are associated or not and whether their scatter in the association is high or low:<ul>\n<li>A value close to 1 shows signifies strong positive association between $x$ and $y$, while a value close to $-1$ shows a strong inverse association</li>\n<li>A value near 0 indicates there is no association and there is a large scatter</li>\n</ul>\n</li>\n<li>This is only approximate when $x$ and $y$ are roughly linearly associated (does not work well with association is curved)</li>\n<li>Do not use correlation to imply $x$ causes $y$ or the other way around</li>\n</ul>\n<h2 id=\"bias-and-variance\">Bias and Variance</h2>\n<p><strong>Bias</strong> is the difference between the average prediction of our model and the correct value.</p>\n<ul>\n<li>Models with high bias pays very little attention to the training data and oversimplifies the model.</li>\n<li>It always leads to high error on training and test data.</li>\n</ul>\n<p><strong>Variance</strong> is the variability of model prediction for a given data point or a value which tells us spread of our data.</p>\n<ul>\n<li>Models with high variances pays a lot of attention to training data and does not generalize unseen data.</li>\n<li>As a result, such models perform very well on training data but has high error rates on test data.</li>\n</ul>\n<h3 id=\"bias-variance-decomposition\">Bias-Variance Decomposition</h3>\n<p>When we assume $y = f + \\epsilon$ and we estimate $f$ with $\\hat{f}$, the expectation of error:</p>\n<p>$$E[(y - \\hat{f})^2] = (f - E[\\hat{f}])^2 + Var(\\hat{f}) + Var(\\epsilon)$$</p>\n<p>So, the mean of squared error (MSE) can be written as</p>\n<p>$$MSE = Bias^2 + Variance + Irreducible Error$$</p>\n<ul>\n<li><strong>Irreducible error</strong> is associated with a natural variability in a system (noise).\nIt can not be reduced since it is due to unknown factors or due to chance.</li>\n<li><strong>Reducible error</strong>, as the name suggests, can be and should be minimized further by adjustments to the model.</li>\n</ul>\n<h3 id=\"bias-variance-tradeoff\">Bias-Variance Tradeoff</h3>\n<p>When comparing unbiased estimators, we would like select the one with minimum variance</p>\n<ul>\n<li>If our model is too simple and has very few parameters, then it may have high bias and low variance.</li>\n<li>If it has a large number of parameters, it may have high variance and low bias.</li>\n</ul>\n<h1 id=\"regression\"><a href=\"#regression\">Regression</a></h1>\n\n<p>Regression can be used to predict numeric values from numeric attributes.\nIn linear models, the outcome is a linear combination of attributes:</p>\n<p>$$\\hat{y} = \\theta_0 + \\theta_1 x_1 + \\theta_2 x_2 + ... + \\theta_n x_n = \\sum_{i=0}^n \\theta_i x_i = h(x)$$</p>\n<p>There is:</p>\n<ul>\n<li>Univariate regression: one input variable/feature/attribute is used to predict one output variable</li>\n<li>Multiple regression / multivariable regression: more than one variable/features/attributes are used to predict one output variable</li>\n</ul>\n<h2 id=\"least-squares\">Least Squares</h2>\n<p>The most popular estimation model is &quot;Least Squares&quot; for fitting a linear regression.\nError is defined as difference between the predicted and actual value, i.e.</p>\n<p>$$J(\\theta) = \\sum_{y=1}^m \\left(y_j - \\sum_{i=0}^n \\theta_i x_{ji} \\right)^2 = \\sum_{j=1}^m \\left(y_j - x_j^T \\theta \\right)^2 = (y - X \\theta)^T (y - X \\theta)$$</p>\n<p>We want to minimize the error over all samples.</p>\n<h2 id=\"gradient-descent\">Gradient Descent</h2>\n<p>The goal of Linear Regression is to minimise $J(\\theta)$.\nIf we compute $J(\\theta)$ for different values of $\\theta$, we get a convex function with one global minima.\nTo find the value of $\\theta$ that provides this minimum, we can use gradient descent.</p>\n<p>Gradient descent starts with some initial $\\theta$, and repeatedly performs an update:</p>\n<p>$$\\theta_i^{(t+1)} := \\theta_t^{(t)} - \\alpha \\frac{\\partial}{\\partial \\theta_i} J \\left( \\theta_i^{(t)} \\right)$$</p>\n<p>where $\\alpha$ is the learning rate / step size, and each iteration it takes a step in the direction of the steepest decrease in $J(\\theta)$.</p>\n<p>The partial derivative term for $J(\\theta)$ can be determined as</p>\n<p>$$\\frac{\\partial}{\\partial \\theta_i} J(\\theta) = -2 \\left( y_j - h_\\theta (x_j) \\right) x_{ji}$$</p>\n<p>So, for a <strong>single training sample</strong>, the update Least Mean Squares (LMS) rule is:</p>\n<p>$$\\theta_{i+1} := \\theta_i + 2 \\alpha \\left( y_j - h_\\theta (x_j) \\right) x_{ji}$$</p>\n<p>For other samples, there are two methods.</p>\n<ol>\n<li><strong>Batch Gradient Descent:</strong>\n$$\\theta_i^{t+1} = \\theta_i^{(t)} + \\alpha \\frac{2}{m} \\sum_{j=1}^m \\left( y_j - h_{\\theta^{(t)}} (x_j) \\right) x_{ji}$$\nReplace the gradient with the sum of gradient for all samples and continue until convergence (when the estimated $\\theta$ is stabilized).</li>\n<li><strong>Stochastic Gradient Descent:</strong>\n$$ \\text{ for } j = 1 \\text{ to } m \\left\\{ \\theta _ i = \\theta_i + 2 \\alpha \\left( y_jj - h _ \\theta (x _ j) \\right) x _ ji \\text{ for every } i \\right\\}$$</li>\n</ol>\n<p>In stochastic gradient descent, $\\theta$ gets updated at any sample separately, so it is faster to calculate, but may never converge to the minimum.</p>\n<h2 id=\"minimizing-squared-error-normal-equations\">Minimizing Squared Error (normal equations)</h2>\n<p>Gradient descent is an iterative algorithm, however, you may find the minimum of $J(\\theta)$ by finding and setting it&#39;s derivatives to 0.\nThis is also called the exact or closed-form solution.</p>\n<p>$$\n\\frac{\\partial}{\\partial \\theta} J(\\theta) = 0 \\\\\nJ(\\theta) = ( \\mathbb{y} - X \\theta )^T (\\mathbb{y} - X \\theta) \\\\\n\\frac{\\partial}{\\partial \\theta} J(\\theta) = - 2X^T (\\mathbb{y} - X \\theta) = 0 \\\\\nX^T (\\mathbb{y} - X \\theta) = 0 \\\\\n\\theta = (X^TX)^{-1}X^T \\mathbb{y}\n$$</p>\n<h2 id=\"minimizing-squared-error-normal-equations-1\">Minimizing Squared Error (normal equations)</h2>\n<p>We can write the relationship between input variable $x$ and output variable $y$ as:</p>\n<p>$$y_j = x_j^T \\theta + \\epsilon_j$$</p>\n<p>And $\\epsilon_j$ is an error term which might be unmodeled effect or random noise.\nAssume $\\epsilon_j$&#39;s are independent and identically distributed (i.i.d.) according to a Gaussian distribution, i.e.:</p>\n<p>$$\n\\epsilon_j \\sim N \\left( 0, \\sigma^2 \\right) \\\\\np(\\epsilon_j) = \\frac{1}{\\sqrt{2 \\pi \\sigma^2}} \\exp \\left( - \\frac{e_j^2}{2 \\sigma^2} \\right)\n$$</p>\n<p>This implies that:</p>\n<p>$$p(\\epsilon_j) = p(y_j | x_j; \\theta) = \\frac{1}{\\sqrt{2 \\pi \\sigma^2}} \\exp \\left( - \\frac{e_j^2}{2 \\sigma^2} \\right)$$</p>\n<p>So we want to estimate $\\theta$ s.t. we maximise the probability of output $y$ given input $x$ over all $m$ training samples:</p>\n<p>$$\n\\begin{align*}\n\\mathcal{L}(\\theta)\n    &amp;= p(\\mathbb{y} | X, \\theta) \\\\\n    &amp;= \\prod_{j=1}^m \\frac{1}{\\sqrt{2 \\pi \\sigma^2}} \\exp \\left( - \\frac{\\left( y_j - x_j^T \\theta \\right)^2}{2 \\sigma^2} \\right)\n\\end{align*}\n$$</p>\n<p>Note this is called the <strong>Likelihood</strong> function.</p>\n<p>However, to find $\\theta$ that maximises $\\mathcal{L}(\\theta)$, we can also maximise any strictly increasing function of $\\mathcal{L}(\\theta)$.\nIn this case, we can find <strong>maximize the log likelihood</strong> $mathcal{l}(\\theta)$:</p>\n<p>$$\n\\begin{align*}\n\\mathcal{l}(\\theta)\n    &amp;= \\log \\mathcal{L}(\\theta) \\\\\n    &amp;= \\log \\prod_{j=1}^m \\frac{1}{\\sqrt{2 \\pi \\sigma^2}} \\exp \\left( - \\frac{\\left( y_j - x_j^T \\theta \\right)^2}{2 \\sigma^2} \\right) \\\\\n    &amp;= m \\log \\left( \\frac{1}{\\sqrt{2 \\pi \\sigma^2}} \\right) - \\frac{1}{\\sigma^2} \\frac{1}{2} \\sum_{j=1}^m \\left( y_j - x_j^T \\theta \\right)^2\n\\end{align*}\n$$</p>\n<p>So maximizing $\\mathcal{l}(\\theta)$ is equal to minimising $\\sum_{j=1}^m \\left( y_j - x_j^T \\theta \\right)^2$.\nThis means under certain assumptions, the least squared regression is equivalent to finding maximum likelihood estimate of $\\theta$.</p>\n<h2 id=\"linear-regression-assumptions\">Linear Regression Assumptions</h2>\n<ul>\n<li><strong>Linearity:</strong> The relationship between $x$ and the mean of $y$ is linear</li>\n<li><strong>Homoscedasticity:</strong> The variance of residual is the same of any value of $x$</li>\n<li><strong>Independence:</strong> Observations are independent of each other</li>\n<li><strong>Normality:</strong> For any fixed value of $x$, $y$ is normally distributed</li>\n</ul>\n<h2 id=\"univariate-linear-regression\">Univariate Linear Regression</h2>\n<p>In univariate regression we aim to find the relationship between $y$ and one independent variable $x$.</p>\n<p>As an example, if we want to investigate the relationship between height and weight, we could collect $m$ measurements</p>\n<p>$$(h_j, w_j), \\quad j = 1, ..., m$$</p>\n<p>Univariate linear regression assumes a linear relation, $\\hat{w} = \\theta_0 + \\theta_1 h$.</p>\n<h2 id=\"multiple-linear-regression\">Multiple Linear Regression</h2>\n<p>Here, we model the relationship of $y$ to several other variables.</p>\n<p>As an example, say we now want to predict people&#39;s weight from their height and body frame size (i.e. wrist size).\nWe collect $m$, height, weight and body frame measurements:</p>\n<p>$$(h_j, f_j, w_j), \\quad j = 1, ..., m$$</p>\n<p>The linear regression model is now:</p>\n<p>$$\\hat{w} = \\theta_0 + \\theta_1 h + \\theta_2 f$$</p>\n<h2 id=\"linear-regression-for-curves\">Linear Regression for curves</h2>\n<p>We can also apply some changes to produce curves with linear regression, i.e.</p>\n<p>To model:</p>\n<p>$$\\hat{y} = \\theta_0 + \\theta_1 x_1 + \\theta_2 x_1^2$$</p>\n<p>we can treat $x_2 = x_1^2$ and use the model</p>\n<p>$$\\hat{y} = \\theta_0 + \\theta_1 x_1 + \\theta_2 x_2$$</p>\n<p>These nonlinear models can still be treated like linear regression and can fit curvature.\nThey are still linear in parameters.\nNon linear regression is not linear in parameters, i.e., $\\hat{y} = \\frac{\\theta_1 x}{\\theta_2 + x}$</p>\n<p>However, increasing the degree of the model can result in overfitting.</p>\n<h2 id=\"regularisation\">Regularisation</h2>\n<p>Regularisation is a method to avoid overfitting by adding constraints to the weight vector.\nAn approach is to ensure the weights are, small in magnitude: this is called shrinkage.</p>\n<p>The cost function, given data $(x_1, y_1), ..., (x_m, y_m)$ is</p>\n<p>$$J(\\theta) = \\sum_j (y_j - h_\\theta (x_j))^2 + \\lambda \\sum_i \\theta_i^2$$</p>\n<ul>\n<li>Parameter estimation by optimisation wil attempt to find values for $\\theta_0, ..., \\theta_n$ s.t. $J(\\theta)$ is a minimum</li>\n<li>Similar to before, this can be solved by gradient descent or finding the closed form solution</li>\n</ul>\n<p>The multiple least-squares regression problem is an optimisation problem, and can be written as:</p>\n<p>$$\\theta* = \\arg \\min_\\theta (y - X \\theta)^T (y - X\\theta)$$</p>\n<p>The regularised version of this is then as follows:</p>\n<p>$$\\theta* = \\arg \\min (y - X \\theta)^T (y - X \\theta) + \\lambda || \\theta ||^2$$</p>\n<p>Where $||\\theta||^2 = \\sum_i \\theta_i^2$ is the squared norm of the vector $\\theta$, or equivalently, the dot product $\\theta^T\\theta$; $\\lambda$ is a scalar determining the amount of regularisation.</p>\n<p>This still has a closed form solution</p>\n<p>$$\\theta = (X^TX + \\lambda I)^{-1} X^T y$$</p>\n<p>where $I$ is the identity matrix.\nRegularisation amounts to adding $\\lambda$ to the diagonal of $X^TX$, improves the numerical stability of matrix inversion.\nThis form of least-squares regression is known as <strong>ridge regression</strong>.</p>\n<p>An alterative of regularised regression is provided by the <strong>lasso</strong>.\nIt replaces the term $\\sum_i \\theta_i^2$ with $\\sum_i |\\theta_i |$.\nThe result is that some weights are shrunk, but others are set to 0, hence this favours sparse solutions.</p>\n<h2 id=\"model-selection\">Model Selection</h2>\n<p>Suppose there are a lot of variables / features $(x)$.\nTaking all the features will lead to an overly complex model.\nThere are 3 ways to reduce complexity.</p>\n<ol>\n<li><strong>Subset-selection</strong>, by search over subset lattice.\nEach subset results in a new model, and the problem is so select one of the models.</li>\n<li><strong>Shrinkage</strong>, or regularization of coefficients to zero, by optimization.\nThere is a single model, and unimportant variables have near-zero coefficients.</li>\n<li><strong>Dimensionality-reduction</strong>, by projecting points into a lower dimensional space (this is different to subset-selection)</li>\n</ol>\n<h1 id=\"classification\"><a href=\"#classification\">Classification</a></h1>\n\n<p>Classification doesn&#39;t have convenient mathematical properties, so in classification, train a classifier, which is usually a function that maps from an input data point to a set of discrete outputs (i.e. the classes).</p>\n<ul>\n<li><strong>Generative algorithm:</strong>\nbuilds some models for each of the classes and then makes classification predictions based on looking at the test example see it is more similar to which of the models<ul>\n<li>Learns $p(x|y)$</li>\n<li>So, we can get $p(x,y) = p(x|y)p(y)$</li>\n<li>It learns the mechanism by which the data has been generated</li>\n</ul>\n</li>\n<li><strong>Discriminative algorithm:</strong>\nDo not build models for difference classes, but rather focuses on finding a decision boundary that separates classes<ul>\n<li>Learns $p(y|x)$</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"linear-classification\">Linear Classification</h2>\n<p>For a linear classifier of 2 features and 2 classes</p>\n<ul>\n<li>We a line that separates the two classes: $ax_1 + bx_2 + c = 0$.</li>\n<li>We define a weight vector $w^T = [a,b]$, $x^T = [x_1,x_2]$.</li>\n<li>So, the line can be defined by $x^Tw = -c = t$</li>\n<li>$w$ is perpendicular to the decision boundary</li>\n<li>$t$ is the decision threshold (if $x^Tw &gt; t$, $x$ belongs to $P$ but if $x^Tw &lt; t$, $x$ belongs to $N$)</li>\n</ul>\n<p>If $p$ and $n$ is the respective centers of mass of the positive and negative points, the basic linear classifier is described by the equation $x^Tw = t$ and $w = p - n$.</p>\n<p>As we know, $\\frac{p+n}{2}$ is on the decision boundary, so we have:</p>\n<p>$$t = \\left( \\frac{p+n}{2} \\right)^T \\cdot (p-n) = \\frac{||p||^2 - ||n||^2}{2}$$</p>\n<p>where $||x||$ denotes the length of vector $x$.</p>\n<h2 id=\"generalisation\">Generalisation</h2>\n<p>Generalisation means how well a trained model can classify or forecast unseen data.\nThere are 3 basic assumptions for generalisation</p>\n<ol>\n<li>Examples are drawn independent and identically (i.i.d) at random for the distribution</li>\n<li>The distribution is stationary; that is the distribution doesn&#39;t change within the data set</li>\n<li>We always pull from the same distribution (for training, validation and test samples)</li>\n</ol>\n<h2 id=\"cross-validation\">Cross-validation</h2>\n<p>CV is a validation technique to assess the results of a model to an independent data set.\nA portion of the dataset is used to train the model, and another is used to test.\nTypes of CV include:</p>\n<ol>\n<li><strong>Holdout method</strong>\nRandomly assign data points to two sets $d_0$ (training set) and $d_1$ (test set).</li>\n<li><strong>Leave-One-Out Cross validation (LOOCV)</strong>\nA variation of the leave-p-out cross validation where 1 sample is left out, to test, whilst the rest is used for training.</li>\n<li><strong>K-fold Cross Validation</strong>\nPartition the dataset into $k$ equally sized subsamples.\nOf the $k$ subsamples, one subsample is used as for testing, and the rest for training.\nRepeat with all subsets to produce a single estimation</li>\n</ol>\n<p>There are certain parameters that need to be estimated during learning.\nWe use the data, but NOT the training set, OR the test set.\nInstead we use a separate validation or development set.</p>\n<p><strong>Validation set:</strong> To make the hyperparameter tuning and model selection independent from the test set, we define another set within the train set.</p>\n<h2 id=\"evaluation-of-error\">Evaluation of error</h2>\n<p>If we have a binary classification, we can have a contingency table, AKA confusion matrix:</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>Predicted Positive</th>\n<th>Predicted Negative</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Actual Positive</strong></td>\n<td>True Positive (TP)</td>\n<td>False Negative (FN)</td>\n</tr>\n<tr>\n<td><strong>Actual Negative</strong></td>\n<td>False Positive (FN)</td>\n<td>True Negative (TN)</td>\n</tr>\n</tbody></table>\n<p>Classification Accuracy on a sample of labelled pairs $(x,c(x))$ given a learned classification model that predicts, for each instance $x$, a class value $\\hat{c}(x)$:</p>\n<p>$$acc = \\frac{1}{|Test|} \\sum_{x \\in Test} I[ \\hat{c}(x) = c(x) ]$$</p>\n<p>where $Test$ is a test set, and $I[]$ is the indicator function which is 1 iff its argument evaluates to true and 0 otherwise.\nThe classification Error $= 1 - acc$.</p>\n<p>Other evaluation metrics:</p>\n<p><strong>Precision / correctness</strong></p>\n<ul>\n<li>is the number of relevant objects classified correctly divided byt he total number of relevant objects classified</li>\n</ul>\n<p>$$Precision = \\frac{TP}{TP + FP}$$</p>\n<p><strong>Recall / sensitivity / completeness / true positive rate (TPR)</strong>\nis the number of relevant objects classified correctly divided by total number of relevant / correct objects</p>\n<p>$$Recall = \\frac{TP}{TP + FN}$$</p>\n<p><strong>F1 score</strong>\nis the harmonic mean of precision and recall and is defined as:</p>\n<p>$$F_1 = \\frac{2 \\times precision \\times recall}{precision + recall}$$</p>\n<p>This measure gives equal importance to precision and recall which is sometime undesirable; so, we have to decide which metric to use depending on the task and what&#39;s important for the task.</p>\n<p><strong>AUC-ROC (Area Under the Curve - Receiver Operating Characteristics)</strong>\nis an important curve for performance of classification models.\nIt evaluates the model at different threshold settings and can inform the capability of the model in distinguishing between classes.</p>\n<ul>\n<li>$TPR = \\frac{TP}{TP+FN}$</li>\n<li>$FPR = \\frac{FP}{FP+TN}$</li>\n<li>A good model has AUC close to 1, a very poor model has AUC close to 0, if the AUC = 0.5, it means there is no class separation</li>\n</ul>\n<div class=\"tikz-diagram\">\n  <img src=\"/tikz-cache/tikz-2ea4818fbebd91c5001d9ebf2ca346e6.svg\" alt=\"TikZ Diagram\" class=\"tikz-svg\" />\n</div>\n\n<h2 id=\"missing-values\">Missing Values</h2>\n<p>Often times data may be incomplete / missing labels.\nTo handle this, there are several strategies:</p>\n<ul>\n<li><strong>Delete samples with missing values</strong><ul>\n<li>Pros:\nA robust and probably more accurate model.</li>\n<li>Cons:\nLoss of information and data.\nBecomes a poorly trained model if percentage of missing values is high.</li>\n</ul>\n</li>\n<li><strong>Replace missing value with mean/median/mode</strong><ul>\n<li>Pros:\nWhen data size is small, it is better than deleting and can prevent data loss.</li>\n<li>Cons:\nInputting the approximations add bias to the model (it reduces the variance).\nAlso works poorly compared to other models.</li>\n</ul>\n</li>\n<li><strong>If categorical, assigning a unique category or the most frequent category</strong><ul>\n<li>Pros:\nWorks well with small datasets and easy to implement and results in no loss of data.</li>\n<li>Cons:\nUnique category works only for categorical features.\nAdding another feature (e.g., a new unique category) to the model may result in high variance in the model.\nAdding the most frequent category can increase the bias in the model.</li>\n</ul>\n</li>\n<li><strong>Predicting the missing values</strong><ul>\n<li>Pros:\nInputting the missing variable is an improvement as long as the bias from it is smaller than the omitted variable bias.\nAlso yields unbiased estimates of the model parameters.</li>\n<li>Cons:\nBias also arises when an incomplete conditioning set is used for a categorical variable.\nConsidered only as a proxy for the true values.</li>\n</ul>\n</li>\n<li><strong>Using algorithms that support missing values</strong><ul>\n<li>Pros:\nDoes not require creation of a predictive model however, correlation of the data is neglected.</li>\n<li>Cons:\nSome of these algorithms are very time-consuming and it can be critical in data mining where large databases are being extracted.</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"nearest-neighbour\">Nearest Neighbour</h2>\n<p>Nearest Neighbour is a regression or classification algorithm that predicts whatever is the output value of the nearest data point to some query.</p>\n<p>To find the nearest data point, we have to find the distance between the query and other points. So we have to decide how to define the distance.</p>\n<h3 id=\"minkowski-distance\">Minkowski Distance</h3>\n<p>If $\\mathcal{X} \\rightarrow \\mathbb{R}^d$, $x, in \\in \\mathcal{X}$, the Minkowski distance of order $p &gt; 0$ is defined as:</p>\n<p>$$Dist_p(x,y) = \\left( \\sum_{j=1}^d |x_j - y_j|^P \\right)^{\\frac{1}{p}} = ||x-y||_p$$</p>\n<p>Where $||z||_p = \\left( \\sum_{j=1}^d |z_j|^p \\right)^{\\frac{1}{p}}$ is the p-norm (sometimes denoted $L_p$ norm) of the vector $z$.</p>\n<ul>\n<li>The 2-norm refers to the euclidean distance</li>\n<li>The 1-norm denotes manhattan distance, also called cityblock distance</li>\n</ul>\n<p>If we let $p$ grow larger, the distance will be more dominated by the largest coordinate-wise distance, from which we can infer that $Dist_\\infty = max_j | x_j - y_j|$; this is also called Chebyshev distance.</p>\n<p>If the data is not in $\\mathcal{R}^d$, but we can turn it into Boolean features / character sequences, we can still apply distance measures, i.e.</p>\n<table>\n<thead>\n<tr>\n<th>Data type</th>\n<th>Distance Measure</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Equal Length Binary String</td>\n<td>Hamming Distance</td>\n</tr>\n<tr>\n<td>Unequal Length Non-Binary String</td>\n<td>Levenshtein Distance</td>\n</tr>\n</tbody></table>\n<h3 id=\"distance-metrics\">Distance Metrics</h3>\n<p>Given an instance space $\\mathcal{X}$, a distance metric is a function $Dist : \\mathcal{X} \\times \\mathcal{X} \\rightarrow [0, \\infty)$ such that for any $x,y,z \\in \\mathcal{X}$</p>\n<ol>\n<li>Distances between a point and itself are zero</li>\n<li>All other distances are larger than zero</li>\n<li>Distances are symmetric</li>\n<li>Detours can not shorten the distance (triangle inequality)</li>\n</ol>\n<p>If the second condition is weakened to a non-strict inequality - i.e. $Dist(x,y) = 0, x \\neq y$, the function $Dist$ is called a pseudo-metric.</p>\n<p>The arithmetic mean $\\mu$ of a set of data points $D$ in a Euclidean space is the unique point that minimises the sum of squared Euclidean distances to those data points.</p>\n<ul>\n<li>Note minimising the sum of squared Euclidean distances of a given set of points is the same as minimising the average squared Euclidean distance</li>\n<li>If we drop the squares, the point is known as the geometric median<ul>\n<li>For univariate data, it corresponds to the median / middle value of a set of numbers</li>\n<li>For multivariate data, there is no closed-form expression, and needs to be calculated by successive approximation</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"nearest-centroid-classifier\">Nearest Centroid Classifier</h2>\n<p>This is a classifier based on minimum distance principle, where the class exemplars are just the centroids (or means).</p>\n<p><strong>Pros:</strong></p>\n<ul>\n<li>Simple and fast</li>\n<li>Works well when classes are compact and far from each other</li>\n</ul>\n<p><strong>Cons:</strong></p>\n<ul>\n<li>For complex classes (e.g. Multimodal, non-spherical) may give very poor results</li>\n<li>Cannot handle outliers or noisy data well and cannot handle missing data</li>\n</ul>\n<h2 id=\"nearest-neighbour-classification\">Nearest Neighbour Classification</h2>\n<p>This is related to the simplest form of learning</p>\n<ul>\n<li>Training instances are searched for instance that most closely resembles new or query instances</li>\n<li>The instances themselves represent the knowledge</li>\n<li>Called: instance based, memory based learning or case based learning; often a form of local learning</li>\n</ul>\n<p>Nearest neighbour:</p>\n<ul>\n<li>Given query instance $x_q$, first locate nearest training example $x_n$, then estimate $\\hat{f}(x_q) \\leftarrow f(x_n)$</li>\n</ul>\n<p>$k$-Nearest neighbour:</p>\n<ul>\n<li>Given $x_q$ take vote among its $k$ nearest neighbours (if discrete-valued targe function)</li>\n<li>Take mean of $f$ values of $k$ nearest neighours (if real valued)\n$$\\hat{f}(x_q) \\leftarrow \\frac{\\sum_{j=1}^kf(x_j)}{k}$$</li>\n</ul>\n<p><strong>Pros:</strong></p>\n<ul>\n<li>Can be very accurate</li>\n<li>Training is very fast</li>\n<li>can learn complex target functions</li>\n</ul>\n<p><strong>Cons:</strong></p>\n<ul>\n<li>Slow at query time: basic algorithm scans entire training data to derive a prediction, and suffers from &quot;curse of dimensionality&quot;</li>\n<li>Assumes all attributes are equally important, so easily fooled by irrelevant attributes (can be remedied by attribute selection or weights)</li>\n<li>Problem of noisy instances (can be remedied by removing those from data set, but it&#39;s difficult to determine which are noisy)</li>\n<li>Finding the optimal $k$ can be challenging<ul>\n<li>1NN perfectly separates training data, so low bias but high variance</li>\n<li>By increasing $k$, we increase bias and decrease variance</li>\n</ul>\n</li>\n<li>Needs homogenous feature type and scale</li>\n</ul>\n<p>Note that the data needs to be normalized because different attributes may be measured on different scales, i.e.\n$$x&#39; = \\frac{x - \\min(x)}{\\max(x) - \\min(x)}$$</p>\n<p>where $x$ is the actual value of attribute / feature, and $x&#39;$ is the normalized value.</p>\n<p>Nearest Neighbour should be considered when</p>\n<ul>\n<li>Instances map to points in $\\mathbb{R}^d$</li>\n<li>There are less than 20 attributes per instance (or number of attributes can be reduced)</li>\n<li>There is lots of training data</li>\n<li>No requirement for &quot;explanatory&quot; model to be learned</li>\n</ul>\n<h2 id=\"distance-weighted-knn\">Distance-Weighted KNN</h2>\n<p>We might want to use the distance function to construct a weight $w_i$.\nThe final line of the classification algorithm can be changed to be</p>\n<p>$$\\hat{f}(x_q) \\leftarrow \\arg \\max_{v \\in V} \\sum_{i=1}^k w_i \\delta(v,(f(x_j)))$$</p>\n<p>where</p>\n<p>$$w_i = \\frac{1}{Dist(x_q, x_i)^2}$$</p>\n<p>For real-valued target functions, the final line can be changed to be</p>\n<p>$$\\hat{f}(x_q) \\leftarrow \\frac{\\sum_{i=1}^k w_i f(x_i)}{\\sum_{i=1}^k w_i}$$</p>\n<ul>\n<li>Note the denominator normalizes the contribution of individual weights</li>\n<li>Now we can consider using all the training examples.<ul>\n<li>Using all examples (i.e. when $k = m$) with the rule above is called Shepard&#39;s method</li>\n</ul>\n</li>\n</ul>\n<p>Lazy learners like this do not construct a model, i.e.</p>\n<ul>\n<li>1-NN: training set error is always 0</li>\n<li>$k$-NN: overfitting may be hard to detect</li>\n</ul>\n<p>The solution is to use Leave-one-out cross-validation (LOOCV), ie. leave out one example and predict it given the rest.</p>\n<h3 id=\"curse-of-dimensionality\">Curse of Dimensionality</h3>\n<p>As dimension increases, the effectiveness of distance metrics decrease, and the concept of proximity may not be qualitatively meaningful as all points look equidistant.</p>\n<p>Some other problems include:</p>\n<ul>\n<li>It becomes polynomially harder to estimate many parameters (e.g. covariances)</li>\n<li>It becomes more difficult to visualize data</li>\n<li>Enormous amount of data is needed to train a model</li>\n<li>Number of &quot;cells&quot; / data points in the instance space grows exponentially in the number of features</li>\n</ul>\n<p>One approach to overcome the curse of dimensionality:</p>\n<ul>\n<li>Stretch $j^{th}$ axis by weight $z_j$, where $z_1, ..., z_d$ is chosen to minimize prediction error</li>\n<li>Use cross-validation to automatically choose weights $z_1, ..., z_d$</li>\n<li>Note setting $z_j$ to zero eliminates this dimension altogether</li>\n</ul>\n<h2 id=\"inductive-bias\">Inductive Bias</h2>\n<p>Inductive Bias is the combination of assumptions and restrictions placed on the models and algorithms used to solve a learning problem.\nIt means the algorithm and model combination you are using to solve the learning problem is appropriate for the task.</p>\n<h2 id=\"bayesian-methods\">Bayesian Methods</h2>\n<p>Provides practical learning algorithms:</p>\n<ul>\n<li>Naive Bayes classifier learning</li>\n<li>Bayesian networking learning, etc</li>\n<li>Combines prior knowledge (prior probabilities) with observed data</li>\n</ul>\n<p>Provides useful conceptual framework</p>\n<ul>\n<li>Provides a &quot;gold standard&quot; for evaluating other learning algorithms</li>\n</ul>\n<p>Bayes theorem is stated as</p>\n<p>$$P(h|D) = \\frac{P(D|h)P(h)}{P(D)}$$</p>\n<p>where</p>\n<ul>\n<li>$P(h)$ = prior probability of hypothesis $h$</li>\n<li>$P(D)$ = prior probability of training data $D$</li>\n<li>$P(h|D)$ = probability of $h$ given $D$</li>\n<li>$P(D|h)$ = probability of $D$ given $h$</li>\n</ul>\n<h3 id=\"choosing-hypotheses\">Choosing Hypotheses</h3>\n<p>If the output belongs to a set of $k$ classes: $y \\in \\{ C_1, C_2, ..., C_k \\}$ for $1 \\leq i \\leq k$.</p>\n<p>Then in Bayesian framework:</p>\n<p>$$P(y = C_i | x) = \\frac{P(x|C_i)P(C_i)}{P(x)}$$</p>\n<p>where $P(x) = \\sum_i P(x|C_i)(P(C_i)$</p>\n<p>The decision rule is to select a class which maximises the posterior probability for the prediction.</p>\n<p>Generally we want the most probable hypothesis given the training data, Maximum a posteriori hypothesis $h_{MAP}$:</p>\n<p>$$\n\\begin{align*}\nh_{MAP}\n    &amp;= \\arg \\max_{h \\in H} P(h|D) \\\\\n    &amp;= \\arg \\max_{h \\in H} \\frac{P(D|h)P(h)}{P(D)} \\\\\n    &amp;= \\arg \\max_{h \\in H} P(D|h)P(h)\n\\end{align*}\n$$</p>\n<p>To get the posterior probability of a hypothesis $h$</p>\n<p>Divide $P$ ($\\oplus$) (probability of data) to normalize result for $h$:</p>\n<p>$$P(h|D) = \\frac{P(D|h) P(h)}{\\sum_{h_i \\in H}P(D|h_i)P(h_i)}$$</p>\n<p>Denominator ensures we obtain posterior probabilities that sum to 1.\nSum for all possible numerator values, since hypotheses are mutually exclusive.</p>\n<ul>\n<li>Product Rule: probabiltiy $P(A \\land B)$ of conjunction of two events $A$ and $B$:\n$$P(A \\land B) = P(A|B)P(B) = P(B|A)P(A)$$</li>\n<li>Sum rule: probability of disjunction of two events $A$ and $B$:\n$$P(A \\lor B) = P(A) + P(B) - P(A \\land B)$$</li>\n</ul>\n<p>Theorem of total probability: if events $A_1, ..., A_n$ are mutually exclusive with $\\sum_{i=1}^n P(A_i) = 1$, then:</p>\n<p>$$P(B) = \\sum_{i=1}^n P(B|A_i)P(A_i)$$</p>\n<h3 id=\"bayesian-expected-loss\">Bayesian Expected Loss</h3>\n<p>So far, we decide $h_1$ if $P(h_1|D) &gt; P(h_2|D)$ else $h_2$.\nAlternatively, we can use a loss function $L(h)$, where $L(h)$ is the loss that occurs when decision $h$ is made.</p>\n<p>For example, if the cost of misclassifying a patient who has cancer as &quot;not cancer&quot; is 10 times more than classifying a patient who doesn&#39;t have cancer as &quot;cancer&quot;, who will that affect our decision?</p>\n<p>If the cost of misclassification is not the same for different classes, then instead of maximizing a posteriori, we have to minimize the expected loss:</p>\n<ul>\n<li>So, if we define the loss associated to action $\\alpha_i$ as $\\lambda(\\alpha_i|h)$</li>\n<li>Then the expected loss associated to action $\\alpha_i$ si:\n$$E[L(\\alpha_i)] = R(\\alpha_i | x) = \\sum_{h \\in H} \\lambda (a_i|h) P(h|x)$$</li>\n</ul>\n<p>An optimal Bayesian decision strategy is to minimize the expected loss.</p>\n<h2 id=\"learning-a-real-valued-function\">Learning a real valued function</h2>\n<p>Consider any real-valued target function $f$.\nTraining examples $\\langle x_i, y_i \\rangle$ where $y_i$ is noisy training value</p>\n<ul>\n<li>$y_i = \\hat{f}(x_i) + \\epsilon_i$</li>\n<li>$\\epsilon_i$ is random variable (noise) drawn independently fore ach $x_i$ according to some Gaussian (normal) distribution with mean zero</li>\n</ul>\n<p>Then the maximum likelihood hypothesis $H_{ML}$ is the one that minimizes the sum of squared errors</p>\n<p>$$\n\\begin{align*}\nh_{ML}\n    &amp;= \\arg \\max_{h \\in H} P(D|h) \\\\\n    &amp;= \\arg \\max_{h \\in H} \\prod_{i=1}^m P(y_i|\\hat{f}) \\\\\n    &amp;= \\arg \\max_{h \\in H} \\prod_{i=1}^m \\frac{1}{\\sqrt{2 \\pi \\sigma^2}} \\exp \\left( -\\frac{1}{2} \\left(\\frac{y_i - \\hat{f}(x_i)}{\\sigma} \\right)^2 \\right)\n\\end{align*}\n$$</p>\n<p>where $\\hat{f} = h_{ML}$.</p>\n<p>We can maximise the natural log to give a simpler expression:</p>\n<p>$$\n\\begin{align*}\nh_{ML}\n    &amp;= \\arg \\max_{h \\in H} \\sum_{i=1}^m \\ln \\frac{1}{\\sqrt{2 \\pi \\sigma^2}} - \\frac{1}{2} \\left( \\frac{y_i - \\hat{f}(x_i)}{\\sigma} \\right)^2 \\\\\n    &amp;= \\arg \\max_{h \\in H} \\sum_{i=1}^m - \\frac{1}{2} \\left( \\frac{y_i - \\hat{f}(x_i)}{\\sigma} \\right)^2 \\\\\n    &amp;= \\arg \\max_{h \\in H} \\sum_{i=1}^m - \\left(y_i - \\hat{f}(x_i)\\right)^2 \\\\\n\\end{align*}\n$$</p>\n<p>Equivalently, we can minimise the positive version of the expression:</p>\n<p>$$h_{ML} = \\arg \\min_{h \\in H} \\sum_{i=1}^m \\left( y_i - \\hat{f}(x_i) \\right)^2$$</p>\n<h2 id=\"discriminative-vs-generative-probabilistic-models\">Discriminative vs Generative Probabilistic Models</h2>\n<p><strong>Discriminative models</strong> model the posterior probability distribution $P(y|x)$.\nThat is, given $x$ they return a probability distribution over $y$.</p>\n<p><strong>Generative models</strong> model the joint distribution $P(y,x)$.\nOnce we have the joint distribution, we can derive any conditional or marginal distribution involving the same variables.</p>\n<p>Such models are called &#39;generative&#39; because we can sample from the joint distribution to obtain new data points together with their labels.</p>\n<h2 id=\"bayesian-optimal-classifier\">Bayesian Optimal Classifier</h2>\n<p>In Bayesian optimal classification, the most probable classification\nis obtained by combining the predictions of ALL hypotheses, weighted by their posterior probabilities:</p>\n<p>$$\\arg \\max_{v_j \\in V} \\sum_{h_i \\in H} P(v_j|h_i)P(h_i|D)$$</p>\n<p>where $v_j$ is a class value.</p>\n<p><strong>Pros:</strong></p>\n<ul>\n<li>Mathematically shown no other classification method using the same hypothesis space and prior knowledge outperforms the Bayes Optimal Classifier method on average.</li>\n</ul>\n<p><strong>Cons:</strong></p>\n<ul>\n<li><p>Bayes rule depends on unknown quantities so we need to use the data to find some approximation of those quantities</p>\n</li>\n<li><p>Is very inefficient.\nAn alternative is the <strong>Gibbs algorithm</strong>.</p>\n<ol>\n<li>Choose one hypothesis at random, according to $P(h|D)$</li>\n<li>Use this to classify new instance</li>\n</ol>\n<p>Assuming target concepts are drawn at random from $H$\n$$E[error_{Gibbs}] \\leq 2 \\times E[error_{BayesOptimal}]$$</p>\n</li>\n</ul>\n<h2 id=\"naive-bayes-classifier\">Naive Bayes Classifier</h2>\n<p>When to use</p>\n<ul>\n<li>Moderate or large training set available</li>\n<li>Attributes that describe instances are conditionally independent given classification</li>\n</ul>\n<p>Successful applications:</p>\n<ul>\n<li>Classifying text documents</li>\n<li>Gaussian Naive Bayes for real-valued data</li>\n</ul>\n<p>Assume target function $f : X \\rightarrow V$, where each instance $x$ described by attributes $(x_1, x_2, ..., x_n)$.</p>\n<p>The most probable value of $f(x)$ is:</p>\n<p>$$v_{MAP} = \\arg \\max_{v_j \\in V} P(x_1, x_2, ..., x_n|v_j)P(v_j)$$</p>\n<p>Naive Bayes assumes attributes are statistically independent i.e.</p>\n<p>$$P(x_1, x_2, ..., x_n|v_j) = \\prod_i P(x_i|v_j)$$</p>\n<p>Which gives <strong>Naive Bayes classifier</strong></p>\n<p>$$v_{NB} = \\arg \\max_{v_j \\in V} P(v_j) \\prod_i P(x_i|v_j)$$</p>\n<p>Psuedocode:</p>\n<p>$\\text{for each target value }v_j:$</p>\n<ul>\n<li>$\\hat{P}(v_j) \\leftarrow \\text{estimate}P(v_j)$</li>\n<li>$\\text{for each attribute value } x_i:$<ul>\n<li>$\\hat{P}(x_i|v_j) \\leftarrow$ $\\text{ estimate }$ $P(x_i|v_j)$</li>\n</ul>\n</li>\n</ul>\n<p>If none of the training instances with target value $v_j$ have attribute $x_i$, then:</p>\n<p>$$\n\\hat{P}(x_i|v_j) = 0 \\\\\n\\therefore \\hat{P}(v_j) \\prod_i \\hat{P}(x_i|v_j) = 0\n$$</p>\n<p>Pseudo-counts add 1 to each count (a version of the Laplace Estimator).</p>\n<h3 id=\"naive-bayes-numeric-attributes\">Naive Bayes: numeric attributes</h3>\n<ul>\n<li><p>Usual assumption: attributes have a normal or Gaussian probability distribution (given the class)\n$$x|v_j \\sim N(\\mu,\\sigma^2)$$</p>\n</li>\n<li><p>the probability density function for the normal distribution is defined by two parameters</p>\n<ul>\n<li>The sample mean $\\mu$:\n$$\\mu = \\frac{1}{n}\\sum_{i=1}^n x_i$$</li>\n<li>The standard deviation $\\sigma$:\n$$\\sigma = \\frac{1}{n-1} \\sum_{i=1}^n(x_i - \\mu)^2$$</li>\n</ul>\n</li>\n</ul>\n<p>This gives the density function $f(x)$:</p>\n<p>$$f(x) = \\frac{1}{\\sqrt{2 \\pi \\sigma}} \\exp \\left( \\frac{(x - \\mu)^2}{2 \\sigma^2} \\right)$$</p>\n<h2 id=\"categorical-random-variables\">Categorical Random Variables</h2>\n<p>Categorical variables appear often in ML, i.e. text classification</p>\n<ul>\n<li>The most common form is the Bernoulli distribution model; whether or not a word occurs in a document.<ul>\n<li>For the $i^{th}$ word, we have a random variable $X_i$ governed by a Bernoulli distribution.</li>\n<li>The joint distribution over the bit vector $X = (X_1, ..., X_k)$ is called a <strong>multivariate Bernoulli distribution</strong> which shows whether a word occurs or not</li>\n</ul>\n</li>\n<li>Variables with more than two outcomes are also common.<ul>\n<li>The <strong>multinomial distribution</strong> manifests itself as a count vector: a histogram of the number of occurrences of all vocabulary words</li>\n</ul>\n</li>\n</ul>\n<p><strong>Pros:</strong></p>\n<ul>\n<li>Easy and fast at prediction. Also does well in multi class prediction.</li>\n<li>When assumption of independence holds, performs better than other models like logistic regression with less training data.</li>\n<li>Performs well in case of categorical input variables compared to numerical.</li>\n</ul>\n<p><strong>Cons:</strong></p>\n<ul>\n<li>If zero-frequency case happens, it is unable to make a prediction (solution: use the smoothing technique).</li>\n<li>On the other side Naive Bayes is known as a bad estimator, so the probability outputs cannot be taken too seriously.</li>\n<li>Strong assumption of independent attributes. In real life, it is almost impossible we get a set of attributes which are completely independent.</li>\n</ul>\n<h2 id=\"logistic-regression\">Logistic Regression</h2>\n<p>Logistic regression can be used for binary classification, where we transform the $y$ values into probability values (in the range $[0,1]$).</p>\n<p>We can model this with a sigmoid curve.</p>\n<div class=\"tikz-diagram\">\n  <img src=\"/tikz-cache/tikz-1dd589ccab73f60638a2ce0e9a3a1db6.svg\" alt=\"TikZ Diagram\" class=\"tikz-svg\" />\n</div>\n\n<p>Now $f(x)$ can have a value inbetween $-\\infty$ and $+\\infty$ and in Logistic Regression we estimate $f(x)$ with a line.</p>\n<p>$$\\hat{f}(x) = x^T\\beta \\Rightarrow \\log \\frac{P(y=1|x)}{1-P(y=1|x)}$$</p>\n<p>Logistic regression seeks to</p>\n<ul>\n<li>Model the probability of a class given the values of independent input variables</li>\n<li>Estimate the probability that a class occurs for a random observation</li>\n<li>Classify an observation based on the probability estimations</li>\n</ul>\n<p>$$\\hat{P}(y=1|x) = \\frac{1}{1+e^{-x^T\\beta}}$$</p>\n<ul>\n<li><p>If $P(y=1|x) \\geq 0.5$ (same as saying $x^T\\beta \\geq 0$) then predict as class 1</p>\n</li>\n<li><p>If $P(y=1|x) &lt; 0.5$ (same as saying $x^T\\beta &lt; 0$) then predict as class 0</p>\n</li>\n<li><p>This is equivalent of having a linear decision boundary separating the two classes (because we have a linear solution to our problem, this is what makes Logistic Regression a linear model)</p>\n</li>\n</ul>\n<h3 id=\"logistic-regression-parameter-estimation\">Logistic Regression Parameter Estimation</h3>\n<p>Cannot use cost function in Linear Regression because it will result in a non-convex function with many local minimums.\nInstead, the following cost function is used:</p>\n<p>Let&#39;s define $\\hat{P}(y=1|x) = h_\\beta(x)$</p>\n<p>$$\ncost \\left( h_\\beta(x),y \\right) =\n\\begin{cases}\n  -\\log \\left( h_\\beta(x) \\right) &amp; \\text{if $y = 1$} \\\\\n  -\\log \\left( 1-h_\\beta(x) \\right) &amp; \\text{if $y = 0$}\n\\end{cases}\n$$</p>\n<p>$$J(\\beta) = -\\frac{1}{m} \\sum_{i=1}^m \\left[ y^{(i)} \\log \\left( h_\\beta \\left( x^{(i)} \\right) \\right) + \\left( 1 - y^{(i)} \\right) \\log \\left( 1 - h_\\beta \\left( x^{(i)} \\right) \\right) \\right]$$</p>\n<p>The values of the parameters that minimise $J(\\beta)$ can be found using gradient descent.</p>\n<p><strong>Pros:</strong></p>\n<ul>\n<li>Relatively easy to implement and interpret and relatively fast at training and testing</li>\n<li>Can easily extend to multi-classes</li>\n<li>Provides probabilistic predictions</li>\n</ul>\n<p><strong>Cons:</strong></p>\n<ul>\n<li>Prone to overfitting in high-dimensional data (one remedy: regularization)</li>\n<li>Provides linear decision boundary</li>\n<li>Requires moderate or no correlation (collinearity) between input variables and may lead to poor model, and also sensitive to outliers</li>\n</ul>\n<h1 id=\"tree-learning\"><a href=\"#tree-learning\">Tree Learning</a></h1>\n\n<p>Probably the single most popular tool</p>\n<ul>\n<li>Easy to understand, implement and use</li>\n<li>Computationally cheap (efficient, even on big data)</li>\n</ul>\n<p>Decision tree representation:</p>\n<ul>\n<li>Each internal node tests an attribute</li>\n<li>Each branch corresponds to attribute value</li>\n<li>Each leaf node assigns a classification</li>\n</ul>\n<h2 id=\"decision-tree-expressiveness\">Decision Tree: Expressiveness</h2>\n<p>Decision Trees can be used to represent Boolean functions like AND ($\\land$), OR ($\\lor$), XOR ($\\oplus$)</p>\n<p>$$X \\land Y$$</p>\n<pre><code class=\"language-py\">if X == True:\n    if Y == True: return True\n    if Y == False: return False\nif X == False:\n    return False\n</code></pre>\n<p>$$X \\lor Y$$</p>\n<pre><code class=\"language-py\">if X == True: return True\nif X == False:\n    if Y == True: return True\n    if Y == False: return True\n</code></pre>\n<p>$$X \\oplus Y$$</p>\n<pre><code class=\"language-py\">if X == True:\n    if Y == True: return False\n    if Y == False: return True\nif X == False:\n    if Y == True: return True\n    if Y == False: return False\n</code></pre>\n<p>In general, decisions trees represent a <strong>disjunction of conjunctions</strong></p>\n<p>When to use decision trees:</p>\n<ul>\n<li>Instance described by a mix of numeric features and discrete attribute value pairs</li>\n<li>Target function is discrete valued (otherwise use regression trees)</li>\n<li>Possibly noisy training data</li>\n<li>Interpretability is an advantage</li>\n</ul>\n<p>The main loop for top-down induction of decision trees (TDIDT)</p>\n<ol>\n<li>$A \\leftarrow$ the &quot;best&quot; decision attribute for the next node to split examples</li>\n<li>Assign $A$ as decision attribute for node</li>\n<li>For each value of $A$, create new descendant of node (child node)</li>\n<li>Split training examples to child nodes</li>\n<li>If training examples perfectly classified (pure subset), then STOP ,else iterate over new child nodes</li>\n</ol>\n<h2 id=\"entropy\">Entropy</h2>\n<p>If we want to determine yes or no, is <code>outlook</code> or <code>wind</code> a better attribute</p>\n<pre><code class=\"language-py\">def use_outlook(outlook: attribute) -&gt; dict:\n    match outlook:\n        case sunny: return {&quot;yes&quot;: 2, &quot;no&quot;: 3}\n        case overcast: return {&quot;yes&quot;: 4, &quot;no&quot;: 0}\n        case rain: return {&quot;yes&quot;: 3, &quot;no&quot;: 2}\n\ndef use_wind(wind: attribute) -&gt; dict:\n    match wind:\n        weak: return {&quot;yes&quot;: 6, &quot;no&quot;: 2}\n        strong: return {&quot;yes&quot;: 3, &quot;no&quot;: 3}\n</code></pre>\n<ul>\n<li>We are using a split with higher &quot;purity&quot;</li>\n<li>We need to measure the purity of the split<ul>\n<li>More certain about our classes after a split<ul>\n<li>A set with all examples belonging to one class is 100% pure</li>\n<li>A set with 50% examples in one class and 50% in the other is 100% uncertain and impure</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p><strong>Entropy</strong></p>\n<ul>\n<li>From a statistical point of view</li>\n<li>From information theory point of view: The amount of information (in the Shannon sense) needed to specify the full state of a system</li>\n</ul>\n<p>Entropy measures the &quot;impurity&quot; of $S$.</p>\n<p>$$Entropy(S) = H(S) = -p_\\oplus \\log_2 p_\\oplus - p_\\ominus \\log_2 p_\\ominus$$</p>\n<ul>\n<li>$S$ is subset of training examples</li>\n<li>$p_\\oplus$, $p_\\ominus$ are the portion (%) of positive and negative examples in $S$</li>\n</ul>\n<p>Interpretation: if item $x$ belongs to $S$, how many bits are needed to tell if $x$ is positive or negative?</p>\n<div class=\"tikz-diagram\">\n  <img src=\"/tikz-cache/tikz-d9df73e9a719e07e339e88aaf2a059ba.svg\" alt=\"TikZ Diagram\" class=\"tikz-svg\" />\n</div>\n\n<ul>\n<li>&quot;High Entropy&quot; / &quot;impure set&quot; means $X$ is very uniform and boring<ul>\n<li>E.g. (3 samples from $\\oplus$, 3 samples from $\\ominus$)</li>\n<li>$H(S) = - \\frac{3}{6}\\log_2\\frac{3}{6} - \\frac{3}{6}\\log_2\\frac{3}{6} = 1$ (can be interpreted as 1 bits)</li>\n</ul>\n</li>\n<li>&quot;Low Entropy&quot; / &quot;pure set&quot; means $X$ is not uniform and interesting<ul>\n<li>E.g. (6 samples from $\\oplus$, 0 samples from $\\ominus$)</li>\n<li>$H(S) = - \\frac{6}{6}\\log_2\\frac{6}{6} - \\frac{0}{6}\\log_2 \\frac{0}{6} = 0$ (can be interpreted as 0 bits)</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"information-gain\">Information Gain</h2>\n<p>$Gain(S,A)$ is the expected reduction in entropy due to sorting on $A$</p>\n<p>$$Gain(S,A) = Entropy(S) - \\sum_{v \\in Values(A)} \\frac{|S_v|}{|S|}Entropy(S_v)$$</p>\n<ul>\n<li>$v$ is the possible values of attribute $A$</li>\n<li>$S$ is the set of examples we want to split</li>\n<li>$S_v$ is the subset of examples where $X_A = v$</li>\n</ul>\n<p>We want to find the attribution which maximizes the gain (this is also called &quot;mutual information&quot; between attribute $A$ and class labels of $S$).</p>\n<p>To select the best attribute at each branch:</p>\n<ul>\n<li>take every/remaining attributes in your data</li>\n<li>Compute information gain for that attribute</li>\n<li>Select the attribute that has the highest information gain</li>\n</ul>\n<p><strong>Limitations</strong></p>\n<ul>\n<li>Information gain is more biased towards attributes with large numbers of values / categories<ul>\n<li>Subsets are more likely to be pure if there is a large number of values</li>\n<li>This can result in overfitting which doe snot generalize well to unseen data</li>\n</ul>\n</li>\n<li>Suggested solution: gain ratio<ul>\n<li>A modification of information gain that reduces the bias</li>\n<li>Takes number and size of branches into account</li>\n</ul>\n</li>\n</ul>\n<p><strong>Gain Ratio</strong></p>\n<p>$$SplitEntropy(S,A) = - \\sum_{v \\in Values(A)} \\frac{S_v}{S} \\log_2 \\frac{S_v}{S}$$\nWhere:</p>\n<ul>\n<li>$A$: candidate attribute</li>\n<li>$v$: possible values of $A$</li>\n<li>$S$: Set of examples ($X$) at the node</li>\n<li>$S_v$: subset where $X_A = v$</li>\n</ul>\n<p>$$GainRatio(S,A) = \\frac{Gain(S,A)}{SplitEntropy(S,A)}$$</p>\n<h2 id=\"overfitting-in-decision-trees\">Overfitting in Decision Trees</h2>\n<ul>\n<li>Can always classify training examples perfectly<ul>\n<li>If necessary, keep splitting until each node contains 1 example</li>\n<li>Singleton subset (leaf nodes with one example) which is by definition pure</li>\n</ul>\n</li>\n<li>But this is not always ideal because on leaf nodes with singleton subsets, you have no confidence in your decision</li>\n</ul>\n<p>Consider error of hypothesis $h$ over</p>\n<ul>\n<li>Training data: $error_{train}(h)$</li>\n<li>Entire distribution $D$ of data $error_{D}(h)$</li>\n</ul>\n<p><strong>Definition</strong>\nHypothesis $h \\in H$ overfits training data if there is an alternative hypothesis $h&#39; \\in H$ such that</p>\n<p>$$error_{train}(h) &lt; error_{train}(h&#39;) \\land error_D(h) &gt; error_D(h&#39;)$$</p>\n<p>To avoid overfitting in decision trees, we can use <strong>pruning</strong></p>\n<ul>\n<li><strong>pre-pruning:</strong> Stop growing when data split not statistically significant.<ul>\n<li>Some stopping conditions:<ul>\n<li>Lower than some lower-bound on the number of examples in a leaf</li>\n<li>Stop when Entropy changes is smaller than a lower-bound</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong>post-pruning:</strong> Grow full tree, then remove sub-trees which are overfitting (based on validation set). This avoids the problem of &quot;early stopping&quot;<ul>\n<li>Methods of finding subtrees:<ul>\n<li>Split data into training and validation set, and prune subtrees until further pruning is harmful</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p><strong>Pros:</strong></p>\n<ul>\n<li>Easy to interpret</li>\n<li>Can handle irrelevant attributes (Gain = 0)</li>\n<li>Can handle categorical and numerical data, along with missing data</li>\n<li>Can handle missing data</li>\n<li>Very compact (number of nodes &lt;&lt; number of examples)</li>\n<li>Very fast at testing</li>\n</ul>\n<p><strong>Cons:</strong></p>\n<ul>\n<li>Only axis-aligned splits of the data</li>\n<li>Tend to overfit</li>\n<li>Greedy (may not find the best tree)<ul>\n<li>Exponentially many possible trees</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"regression-tree\">Regression Tree</h2>\n<p>Mention things here</p>\n<h1 id=\"kernel-methods\"><a href=\"#kernel-methods\">Kernel Methods</a></h1>\n\n<table>\n<thead>\n<tr>\n<th>Task</th>\n<th>Label and Output Space</th>\n<th>Learning Problem</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Classification</td>\n<td>$\\mathcal{L} = \\mathcal{C}$, $\\mathcal{Y} = \\mathcal{C}$</td>\n<td>Learn an approximation $\\hat{c} : \\mathcal{X} \\rightarrow \\mathcal{C}$ to the true labelling function $c$</td>\n</tr>\n<tr>\n<td>Scoring and ranking</td>\n<td>$\\mathcal{L} = \\mathcal{C}$, $\\mathcal{Y} = \\mathbb{R}^{|\\mathcal{C}|}$</td>\n<td>Learn a model that outputs a score vector over classes</td>\n</tr>\n<tr>\n<td>Probability estimation</td>\n<td>$\\mathcal{L} = \\mathcal{C}$, $\\mathcal{Y} = [0,1]^{|\\mathcal{C}|}$</td>\n<td>Learn a model that outputs a probability vector over classes</td>\n</tr>\n<tr>\n<td>Regression</td>\n<td>$\\mathcal{L} = \\mathbb{R}$, $\\mathcal{Y} = \\mathbb{R}$</td>\n<td>Learn an approximation $\\hat{f} : \\mathcal{X} \\rightarrow \\mathbb{R}$ to the true labelling function $f$</td>\n</tr>\n</tbody></table>\n<h2 id=\"perceptron\">Perceptron</h2>\n<p><strong>Perceptron</strong> is an algorithm for binary classification that uses a linear prediction function.\nNote the perceptron predicts a binary class label, but linear regression predicts a real value.</p>\n<p>For a general case with $n$ attributes</p>\n<p>$$\nf(x) =\n\\begin{cases}\n    +1 &amp; \\text{if $w_0 + w_1x_1 + ... + w_nx_n &gt; 0$} \\\\\n    -1 &amp; \\text{otherwise}\n\\end{cases}\n$$</p>\n<p>If we add $x_0 = 1$ to the feature vector:</p>\n<p>$$\nf(x) =\n\\begin{cases}\n    +1 &amp; \\text{if $\\sum_{i=0}^n w_ix_i &gt; 0$} \\\\\n    -1 &amp; \\text{otherwise}\n\\end{cases}\n$$</p>\n<p>$$\\hat{y} = f(x) = sign(w \\cdot x)$$</p>\n<p>where $sign$ is the sign function.\nNow to find a good set of weights using our training set.</p>\n<p>The perceptron algorithm initializes all weights $w_i$ to zero, and learns the weights using the following update rule:</p>\n<p>$$w := w + \\frac{1}{2} \\left( y_j - f(x_j) \\right)x_j$$</p>\n<p>There are 4 cases:</p>\n<ol>\n<li>$y=+1, f(x)=+1 \\Rightarrow (y-f(x))=0$</li>\n<li>$y=+1, f(x)=-1 \\Rightarrow (y-f(x))=+2$</li>\n<li>$y=-1, f(x)=+1 \\Rightarrow (y-f(x))=-2$</li>\n<li>$y=-1, f(x)=-1 \\Rightarrow (y-f(x))=0$</li>\n</ol>\n<h3 id=\"perceptron-training-algorithm\">Perceptron training algorithm</h3>\n<p><strong>Algorithm</strong> Perceptron($D$) / perceptron training for linear classification</p>\n<p><strong>Input</strong> labelled training data $D$ in homogeneous coordinates</p>\n<p><strong>Output</strong> weight vector $w$</p>\n<ul>\n<li>$w \\leftarrow 0$</li>\n<li>$converged \\leftarrow false$</li>\n<li>$\\textbf{while } coverged = false \\textbf{ do}$<ul>\n<li>$converged \\leftarrow true$</li>\n<li>$\\textbf{for } i = 1 ..|D| \\textbf{ do}$<ul>\n<li>$\\textbf{if } y_iw \\cdot x_i \\leq 0 \\textbf{ do}$<ul>\n<li>$w \\leftarrow w + y_ix_i$</li>\n<li>$converged \\leftarrow false$</li>\n</ul>\n</li>\n<li>$\\textbf{end}$</li>\n</ul>\n</li>\n<li>$\\textbf{end}$</li>\n</ul>\n</li>\n<li>$\\textbf{end}$</li>\n</ul>\n<h3 id=\"extending-linear-classification\">Extending Linear Classification</h3>\n<p>Linear classification cannot model nonlinear class boundaries.\nHowever we can map attributes into new space consisting combination of attribute values.</p>\n<p>E.g. for 2 attributes</p>\n<p>$$y = w_1x_1^3 + w_2x_1^2x_2 + w_3x_1x_2^2 + w_4x_2^3$$</p>\n<p>$y$ is predicted output for instances with two attributes $x_1$ and $x_2$.</p>\n<p>However, there are issues with this approach</p>\n<ul>\n<li><strong>Efficiency:</strong><ul>\n<li>With 10 attributes and polynomial function with order 5, more than 2000 coefficients have to be learned</li>\n</ul>\n</li>\n<li><strong>Overfitting:</strong><ul>\n<li>&quot;Too nonlinear&quot; - number of coefficients large relative to number of training instances</li>\n<li>Curse of dimensionality</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"dual-form\">Dual Form</h2>\n<p>With an optimisation problem, we can construct another optimisation problem which is called <strong>dual problem</strong> and is related to our original problem (<strong>primal problem</strong>).</p>\n<p>After training a perceptron, each example has been misclassified zero or more times.\nDenoting this number as $\\alpha_i$ for example $x_i$, the weight vector for $m$ observations can be expressed as</p>\n<p>$$w = \\sum_{i=1}^m \\alpha_iy_ix_i$$</p>\n<p>In the dual instance-based view, we are learning instance weights $\\alpha_i$ rather than feature weights $w_j$.\nAn instance $x$ is classified as</p>\n<p>$$\\hat{y} = f(x) = sign(w \\cdot x)$$\n$$\\hat{y} = sign \\left( \\sum_{i=1}^m a_iy_i(x_i \\cdot x) \\right)$$</p>\n<h3 id=\"perceptron-training-algorithm-in-dual-form\">Perceptron training algorithm in dual form</h3>\n<p><strong>Algorithm</strong> Dual-Perceptron($D$) / perceptron training for linear classification in dual form</p>\n<p><strong>Input</strong> labelled training data $D$ in homogeneous coordinates</p>\n<p><strong>Output</strong> coefficients $\\alpha_i$ defining weight vector $W = \\sum_{i=1}^{|D|} \\alpha_i y_i x_i$</p>\n<ul>\n<li>$\\alpha_i \\leftarrow 0$</li>\n<li>$converged \\leftarrow false$</li>\n<li>$\\textbf{while } coverged = false \\textbf{ do}$<ul>\n<li>$converged \\leftarrow true$</li>\n<li>$\\textbf{for } i = 1 ..|D| \\textbf{ do}$<ul>\n<li>$\\textbf{if } y_i \\sum_{j=1}^{|D|} a_j y_j x_j \\cdot x_i\\leq 0 \\textbf{ do}$<ul>\n<li>$\\alpha_i \\leftarrow \\alpha_i + 1$</li>\n<li>$converged \\leftarrow false$</li>\n</ul>\n</li>\n<li>$\\textbf{end}$</li>\n</ul>\n</li>\n<li>$\\textbf{end}$</li>\n</ul>\n</li>\n<li>$\\textbf{end}$</li>\n</ul>\n<h2 id=\"nonlinear-dual-perceptron\">Nonlinear dual perceptron</h2>\n<ul>\n<li>We can use nonlinear mapping to map attributes into new space consisting of combinations of attribute values.\n$$x \\rightarrow \\varphi(x)$$</li>\n<li>The perceptron decision will be:\n$$\\hat{y} = sign \\left( \\sum_{i=1}^m a_j y_i (\\varphi(x_i) \\cdot \\varphi(x))\\right)$$</li>\n<li>So the only thing we need is the <strong>dot product in the new feature space</strong> $(\\varphi(x_i) \\cdot \\varphi(x))$ or $\\langle \\varphi(x_i), \\varphi(x) \\rangle$</li>\n</ul>\n<p>Let $x = (x_1, x_2)$ and $x&#39; = (x_1&#39;, x_2&#39;)$ be two data points, and consider the following mapping to a three-dimensional feature space:</p>\n<p>$$(x_1, x_2) \\rightarrow (x_1^2, x_2^2, \\sqrt{2}x_1x_2)$$</p>\n<p>$$\\text{(original feature space) } \\mathcal{X} \\rightarrow \\mathcal{Z} \\text{ (new feature space)}$$</p>\n<p>The points in feature space corresponding to $x$ and $x&#39;$ are</p>\n<p>$z = (x_1^2, x_2^2, \\sqrt{2}x_1x_2)$ and $z&#39; = (x_1&#39;^2, x_2&#39;^2, \\sqrt{2}x_1&#39;x_2&#39;)$</p>\n<p>The dot product of these two feature vectors is</p>\n<p>$$z \\cdot z&#39; = x_1^2x_1&#39;^2 + x_2^2x_2&#39;^2 + 2x_1x_1&#39;x_2x_2&#39; = (x_1x_1&#39; + x_2x_2&#39;)^2 = (x \\cdot x&#39;)^2$$</p>\n<p>By squaring in original space, we obtain the dot product in the new space.\nA function that directly calculates the dot product in the new feature space from vectors in the original space is called a kernel - here the kernel is $K(x_1,x_2) = (x_1 \\cdot x_2)^2$.</p>\n<p>A <strong>valid kernel</strong> function is equivalent to a <strong>dot product in some space</strong>.</p>\n<p>$$K(x,x&#39;) = \\varphi(x) \\cdot \\varphi(x&#39;)$$</p>\n<ul>\n<li>A kernel function is a <strong>similarity</strong> function that corresponds to a dot product in some expanded feature space.</li>\n<li>Some very useful kernels in machine learning are <strong>polynomial kernel</strong> and <strong>radial basis function kernel (RBF kernel)</strong></li>\n<li>Polynomial kernel is defined as:\n$$K(x,x&#39;) = (x \\cdot x&#39; + c)^q$$</li>\n<li>RBF kernel is defined as:\n$$K(x,x&#39;) = \\exp \\left( - \\frac{||x-x&#39;||^2}{2 \\sigma^2} \\right)$$\n(Using Taylor expansion, it can be shown that RBF kernel is equivalent of mapping features into infinite dimensions)</li>\n</ul>\n<p>Using the kernel trick, the nonlinear perceptron can be solved using the dual form</p>\n<p>$$\\hat{y} = sign\\left( \\sum_{i=1}^m a_i y_i (\\varphi(x_i) \\cdot \\varphi(x)) \\right) = sign\\left( \\sum_{i=1}^m a_i y_i K(x_i, x) \\right)$$</p>\n<h2 id=\"support-vector-machine\">Support Vector Machine</h2>\n<ul>\n<li>Support Vector Machines (SVMs) can find the optimal linear classification by fitting the maximum margin hyperplane that has the greatest separation between classes</li>\n<li>Can avoid overfitting - learn a form of decision boundary called the maximum margin hyperplane</li>\n<li>Fast for mappings to nonlinear spaces<ul>\n<li>employ a mathematical trick (kernel) to avoid the actual creation of new &quot;pseudo-attributes&quot; in transformed instance spaces</li>\n<li>i.e. the nonlinear space is created implicitly</li>\n</ul>\n</li>\n</ul>\n<p>Let $x_s$ be the closest point to the separating hyperplane (line in 2D) with the following equation:</p>\n<p>$$w \\cdot x = t$$</p>\n<p>Let&#39;s have 2 minor technicalities to simply the math later:</p>\n<ol>\n<li><p>Pull out $w_0 : w = [w_0, ..., w_n]$ and $w_0 = -t$, therefore we will have:\n$$w \\cdot x - t = 0$$</p>\n</li>\n<li><p>Normalize $w$:</p>\n<p>We know that $|w \\cdot x_s - t| &gt; 0$ and we know that we can sacle $w$ and $t$ together without having any effect on the hyperplane, so we choose the scale such that:\n$$|w \\cdot x_s - t| = 1$$</p>\n<p>This means $m = 1$.</p>\n</li>\n</ol>\n<p>$w$ is perpendicular to the line (hyperplane).</p>\n<p>For every two points $x&#39;$ and $x&#39;&#39;$ on the line (hyperplane), we can write:</p>\n<p>$$\nw \\cdot x&#39; - t = 0 \\text{ and } w \\cdot x&#39;&#39; - t = 0 \\\\\n\\Rightarrow \\quad w \\cdot (x&#39; - x&#39;&#39;) = 0\n$$</p>\n<p>Since their dot product is 0, it means they are perpendicular.</p>\n<p>Since, distance between the point $x_s$ and the hyperplane can be found as</p>\n<p>$$distance = \\frac{|w \\cdot x_s - t|}{||w||}$$</p>\n<p>And we have $|w \\cdot x_s - t|=1$, so:</p>\n<p>$$distance = \\frac{1}{||w||}$$</p>\n<p>This distance is the <strong>margin</strong> of our classifier which we want to minimize:</p>\n<p>$$\\max \\frac{1}{||w||} \\text{ subject to } \\min_{t=1,...,m} |w \\cdot x_i - t| = 1$$</p>\n<p>(This is not a friendly optimisation as it has &quot;min&quot; in the constraint).</p>\n<p>We can transform the maximization problem into the following minimization problem:</p>\n<p>$$\n\\min_w \\frac{1}{2} ||w||^2 \\text{ subject to } y_i(w \\cdot x_i - t) \\geq 1 \\\\\n\\text{ for } i = 1,...,m, w \\in \\mathbb{R}^n, t \\in \\mathbb{R}\n$$</p>\n<p>This can be solved using Lagrangian multipliers</p>\n<h2 id=\"lagrangian-multipliers\">Lagrangian multipliers</h2>\n<p>In Lagrangian form, the optimization problem becomes:</p>\n<p>$$\\max_{\\alpha_1,...,\\alpha_m} \\min_{x_1,...,x_n} \\mathcal{L}(x_1,...,x_n,\\alpha_1,...,\\alpha_m) \\text{ s.t. } \\alpha_j \\geq 0 \\forall j$$</p>\n<ul>\n<li>first minimizing with respect to $x_1,...,x_n$</li>\n<li>then maximizing with respect to $\\alpha_1,...,\\alpha_m$</li>\n</ul>\n<p>Adding the constraints with multiplier $\\alpha_i$ for each training example gives the Lagrange function:</p>\n<p>$$\n\\begin{align*}\n\\mathcal{w,t,\\alpha_1,...,\\alpha_m}\n  &amp;= \\frac{1}{2} ||w||^2 - \\sum_{i=1}^m \\alpha_i (y_i (w \\cdot x_i - t) - 1) \\\\\n  &amp;= \\frac{1}{2} ||w||^2 - \\sum_{i=1}^m \\alpha_iy_i(w \\cdot x_i) + \\sum_{i=1}^m \\alpha_i y_i t + \\sum_{i=1}^m \\alpha_i \\\\\n  &amp;= \\frac{1}{2} w \\cdot w - w \\cdot \\left( \\sum_{i=1}^m \\alpha_iy_ix_i \\right) + t \\left( \\sum_{i=1}^m \\alpha_i y_i \\right) + \\sum_{i=1}^m \\alpha_i\n\\end{align*}\n$$</p>\n<ul>\n<li>First we have to minimize $\\mathcal{L}$ with respect to $w$ and $t$</li>\n<li>By taking the partial derivative of the Lagrange function with respect to $t$ and setting it to 0, we find:\n$$\\sum_{i=1}^m\\alpha_iy_i = 0$$</li>\n<li>Similarly, by taking the partial derivative of the Lagrange function with respect to $w$ and setting to 0 we obtain:\n$$w = \\sum_{i=1}^m \\alpha_i y_i x_i$$<ul>\n<li>The same expression as we derived for the perceptron</li>\n</ul>\n</li>\n<li>These expressions allows us to eliminate $w$ and $t$ and lead to the dual Lagrangian\n$$\n\\begin{align*}\n\\mathcal{L}(\\alpha_1, ..., \\alpha_n)\n  &amp;= - \\frac{1}{2} \\left( \\sum_{i=1}^m \\alpha_i y_i x_i \\right) \\cdot \\left( \\sum_{i=1}^m \\alpha_i y_i x_i \\right) + \\sum_{i=1}^m \\alpha_i \\\\\n  &amp;= - \\frac{1}{2} \\sum_{i=1}^m \\sum_{j=1}^m \\alpha_i \\alpha_j y_i y_j x_i \\cdot x_j + \\sum_{i=1}^m \\alpha_i\n\\end{align*}\n$$</li>\n</ul>\n<p>The dual optimization problem for SVMs is to maximize the dual Lagrangian under positive constraints and one equality constraint:</p>\n<p>$$\\alpha_i*, ..., \\alpha_m* = \\arg \\max_{\\alpha_1, ..., \\alpha_m} - \\frac{1}{2}\\sum_{i=1}^m \\sum_{j=1}^m \\alpha_i \\alpha_j y_i y_j x_i \\cdot x_j + \\sum_{i=1}^m \\alpha_i $$</p>\n<p>$$\\text{subject to } \\alpha_i \\geq 0, 1 \\leq i \\leq m, \\sum_{i=1}^m \\alpha_i y_i = 0$$</p>\n<p>Solving for $\\alpha_1*, ..., \\alpha_m*$, they will be mostly zero, except for points that are closest to the hyperplane.\nThese points are called the support vectors.</p>\n<p>$$w = \\sum_{X_i \\in \\{ support : vectors\\}} \\alpha_i y_i x_i$$</p>\n<p>Solve for $t$ using any of support vectors:</p>\n<p>$$y_i (w \\cdot x_i - t) = 1$$</p>\n<p><strong>Pros:</strong></p>\n<ul>\n<li>Effective in high dimensional space and when dimension &gt; num samples</li>\n<li>Memory efficient</li>\n<li>Works very well if classes are separable even if non linearly (through kernels)</li>\n</ul>\n<p><strong>Cons:</strong></p>\n<ul>\n<li>Doesn&#39;t scale well to big data (by increasing the number of samples, the number of support vector grows and the prediction will be slow)</li>\n<li>Doesn&#39;t directly provide probabilistic explanation</li>\n<li>Hard to interpret, especially when using kernels</li>\n</ul>\n<h1 id=\"ensemble-learning\"><a href=\"#ensemble-learning\">Ensemble Learning</a></h1>\n\n<p>Ensemble learning is a form of multi-level learning: learning a number of base-level models from the data, and learning to combine these models as an ensemble.</p>\n<p>It can help to reduce <strong>bias</strong> (expected error due to mismatch between learner&#39;s hypothesis space and space of target concepts) and <strong>variance</strong> (expected error due to differences in the training sets used).</p>\n<p>Three commonly used methods to find a good bias-variance tradeoff are:</p>\n<ul>\n<li>Regularization</li>\n<li>Bagging</li>\n<li>Boosting</li>\n</ul>\n<h2 id=\"bias-variance-with-big-data\">Bias-variance with &quot;Big Data&quot;</h2>\n<ul>\n<li>High bias algorithms are often used for efficiency<ul>\n<li>Usually simpler to compute</li>\n</ul>\n</li>\n<li>Big data can reduce variance<ul>\n<li>&quot;small&quot; concepts will occur more frequently</li>\n<li>low bias algorithms can be applied</li>\n</ul>\n</li>\n</ul>\n<p>However, it is difficult to compute big data efficiently.</p>\n<p>The follow scenarios happen in real-world AI</p>\n<ol>\n<li>Training-set error is observed to be high compared to human-level<ul>\n<li>Bias is too high - solution: move to a more expressive (lower bias) model</li>\n</ul>\n</li>\n<li>Training-set error is observed to be similar to human-level, but validation set error is high compared to human-level<ul>\n<li>Variance is too high - solution: get more data, try regularization, ensembles, move to a different model architecture</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"stability\">Stability</h2>\n<p>For some given data $\\mathcal{D}$, train an algorithm $L$ on training sets $S_1$, $S_2$ sampled from $\\mathcal{D}$.\nIf the model from $L$ is very similar on both $S_1$ and $S_2$, $L$ is a stable learning algorithm, otherwise it is unstable.</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>typical stable algorithm</th>\n<th>typical unstable algorithm</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Example model</strong></td>\n<td>$k$NN (for some $k$)</td>\n<td>decision-tree learning</td>\n</tr>\n<tr>\n<td><strong>Cons</strong></td>\n<td>high bias</td>\n<td>high variance</td>\n</tr>\n</tbody></table>\n<p>Note parameters have effect on stability, i.e. in $k$NN:</p>\n<ul>\n<li>1NN perfectly separates training data, so low bias but high variance</li>\n<li>By increasing $k$, we increase bias and decrease variance</li>\n</ul>\n<h2 id=\"supervised-learning\">Supervised Learning</h2>\n<p>Ensemble methods are meta-algorithms that <strong>combine different models</strong> into one model and they can:</p>\n<ul>\n<li>Decrease variance</li>\n<li>Decrease bias</li>\n<li>Improve performance</li>\n</ul>\n<p>This idea relates to the &quot;wisdom of crowd&quot; phenomenon.</p>\n<p>There are different ways of combining predictors</p>\n<ol>\n<li><p>Simple ensembles like majority vote or unweighted average</p>\n</li>\n<li><p>Weighted averages / weighted votes: Every model gets a weight (i.e. depending on its performance)</p>\n<p>In practice:</p>\n<ul>\n<li><p>Learning algorithms may not be independent</p>\n</li>\n<li><p>Some better fit the data so make less error</p>\n<p>We can define weights in different ways:</p>\n</li>\n<li><p>Decrease weight of correlated learners</p>\n</li>\n<li><p>Increase weight of good learners</p>\n</li>\n</ul>\n</li>\n<li><p>Treat the output of each model as a feature and train a model on that</p>\n<ul>\n<li>If the task is binary classification and we choose the fusion model to be a linear model, then this will become a weighted vote</li>\n<li>We train the fusion model on unseen data otherwise it will be biased towards the models that performed better on the training data</li>\n</ul>\n</li>\n<li><p>Mixture of experts</p>\n<ul>\n<li>Weight $\\alpha_i(x)$ indicates &quot;expertise&quot;</li>\n<li>It divides the feature space into homogeneous regions</li>\n<li>It may use a weighted average or just pick the model with largest expertise</li>\n<li>It is a kind of local learning</li>\n</ul>\n</li>\n<li><p>&quot;Bagging&quot; method: (&quot;<strong>B</strong>ootstrap <strong>Agg</strong>regation&quot;)</p>\n<ul>\n<li>Training many classifiers, but each with only a portion of the data</li>\n<li>Then aggregate through model averaging / majority voting</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"bagging\">Bagging</h2>\n<p><strong>Boostrap:</strong></p>\n<ul>\n<li>Create a random subset of data by sampling with replacement</li>\n<li>Draw $m&#39;$ samples from $m$ sample with replacement $(m&#39; \\leq m)$</li>\n</ul>\n<p><strong>Bagging:</strong></p>\n<ul>\n<li>Repeat $k$ times to generate $k$ subsets<ul>\n<li>Some of the samples get repeated and some will not be left out</li>\n</ul>\n</li>\n<li>Train one classifier on each subset</li>\n<li>To test, aggregate the output of $k$ classifiers that you trained in the previous step using either majority vote / unweighted average</li>\n</ul>\n<p>Error of any model has two components:</p>\n<ul>\n<li><strong>Bias:</strong> due to model choice which<ul>\n<li>can be reduced by increasing complexity</li>\n</ul>\n</li>\n<li><strong>Variance:</strong> due to small sample size or high complexity of the model<ul>\n<li>Can be reduced by increasing the data or reducing the complexity</li>\n</ul>\n</li>\n</ul>\n<p>Bagging is applied on a collection of low-bias high-variance models and by averaging them, the bias is unaffected, but the variance reduces.</p>\n<p>To calculate <strong>bagging error:</strong></p>\n<ul>\n<li>If learners are independent</li>\n<li>If each learner makes an error with probability $p$</li>\n</ul>\n<p>The probability that $k&#39;$ out of $k$ learners make an error is:</p>\n<p>$$\\binom{k}{k&#39;}p^{k&#39;}(1-p)^{k-k&#39;}$$</p>\n<p>If we use majority voting to decide the output, then the error happens if more than $\\frac{k}{2}$ of learners make an error, so the error for majority voting is:</p>\n<p>$$\\sum_{k&#39; &gt; \\frac{k}{2}} \\binom{k}{k&#39;}p^{k&#39;}(1-p)^{k-k&#39;}$$</p>\n<p><strong>Advantage of bagging:</strong></p>\n<ul>\n<li>Reduces overfitting (harder for aggregated model to memorize full dataset)</li>\n<li>This improves performance in almost all cases esp if learning scheme is unstable</li>\n<li>Can be applied to numeric prediction and classification</li>\n<li>Can help a lot if data is noisy</li>\n</ul>\n<h2 id=\"random-forests\">Random Forests</h2>\n<p>Tree models can be bagged.</p>\n<p><strong>Pros</strong></p>\n<ul>\n<li>Reduces the overfitting</li>\n<li>Generalizes better</li>\n</ul>\n<p><strong>Cons</strong></p>\n<ul>\n<li>When we bag a model, any simple structure is lost<ul>\n<li>This is because a bagged tree is no longer a tree, but a forest so this reduces claim to interpretability</li>\n<li>stable models like nearest neighbor not very affected by bagging but unstable models like trees most affected by bagging</li>\n</ul>\n</li>\n<li>With lots of data, we usually learn the same classifier, so averaging them does not help</li>\n</ul>\n<p>The solution for ensemble decision trees with lots of data is <strong>random forests</strong>.</p>\n<ul>\n<li>Have extra variability in the learners and introduce more randomness to the procedure.</li>\n</ul>\n<p>To produce a random forest</p>\n<ol>\n<li>Select a random subsample from the dataset with replacement</li>\n<li>Select a subset of features randomly</li>\n<li>Build a full tree without pruning using the selected features and samples</li>\n<li>Repeat previous steps $k$ times</li>\n</ol>\n<h2 id=\"boosting\">Boosting</h2>\n<p>A problem with parallel learners is that they can all be mistaken in the same region.\nBoosting tries to solve this:</p>\n<ul>\n<li>Uses &quot;weak&quot; learners which are trained sequentially</li>\n<li>New learners focus on errors of earlier learners</li>\n<li>New learners try to get these &quot;hard&quot; examples right by operating on a weighted train set in favor of misclassified instances<ul>\n<li>Start with the same weight for all the instances</li>\n<li>Misclassified instances gain higher weights: so the next classifier is more likely to classify it correctly<ul>\n<li>Give different weights to the loss function for different instances</li>\n<li>Create a new collection of data with multiple copies of samples with higher weight</li>\n</ul>\n</li>\n<li>Correctly classified instances lose weight</li>\n</ul>\n</li>\n<li>Combine all learners in the end</li>\n</ul>\n<ol>\n<li>set $w_i = 1/m$ for $i = 1,...,m$</li>\n<li>Repeat until sufficient number of hypothesis<ul>\n<li>Train model $L_j$ using the dataset with weight $w$</li>\n<li>Increase $w_i$ for misclassified instances of $L_j$</li>\n</ul>\n</li>\n<li>Ensemble hypothesis is the weighted majority / weighted average of $k$ learners $L_1, ..., L_k$ with weight $\\lambda_1, ..., \\lambda_k$ which are proportional to the accuracy of $L_j$</li>\n</ol>\n<p>We always aim to minimize some cost function:</p>\n<table>\n<thead>\n<tr>\n<th>Unweighted average loss</th>\n<th>Weighted average loss</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>$J(\\theta) = \\frac{1}{N} \\sum_i J_i (\\theta, x_i)$</td>\n<td>$J(\\theta) = \\sum_i w_iJ_i (\\theta, x_i)$</td>\n</tr>\n</tbody></table>\n<p>Boosting works well as long as we use <strong>weak learners</strong> (weak learner is a model that is slightly better than random), i.e.</p>\n<ul>\n<li>Perceptron</li>\n<li>Decision stumps (trees with one node)</li>\n</ul>\n<h3 id=\"adaboost-adaptive-boosting\">AdaBoost (Adaptive Boosting)</h3>\n<ul>\n<li>AdaBoost usually uses <strong>stump trees</strong> (trees with one node and two leaves) as the base learner<ul>\n<li>Not very accurate at classification on their own</li>\n<li>AdaBoost combines stumps to boost the performance so it creates a forest of stumps instead of forest of trees</li>\n<li>In AdaBoost, stumps are created sequentially</li>\n<li>The error of each stump affects the training data weight in the next stump</li>\n<li>Depending on the performance, each stump gets different weight ($\\lambda_i$) in the final classification decision</li>\n</ul>\n</li>\n</ul>\n<p>For boosting:</p>\n<p><strong>Pros:</strong></p>\n<ul>\n<li>No need to use complex models (can boost performance of any weak learner)</li>\n<li>Very simple to implement</li>\n<li>Decreases the bias and variance</li>\n</ul>\n<p><strong>Cons:</strong></p>\n<ul>\n<li>Lack of interpretability</li>\n<li>Slow during training and potentially testing</li>\n</ul>\n<h3 id=\"gradient-boosting\">Gradient Boosting</h3>\n<p>Gradient boosting is apply similar ideas for regression (but can be used for classification as well).</p>\n<p>Simple linear regression or simple regression trees can be used as weak learners.</p>\n<ol>\n<li>Learn a regression predictor</li>\n<li>Compute the error residual</li>\n<li>Learn to predict residual</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>Bagging</th>\n<th>Boosting</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>Purpose</strong></td>\n<td>Variance reduction</td>\n<td>Bias reduction</td>\n</tr>\n<tr>\n<td><strong>Models Used</strong></td>\n<td>Used with high variance models</td>\n<td>Used with high bias models</td>\n</tr>\n<tr>\n<td><strong>Model Examples</strong></td>\n<td>Random Forests</td>\n<td>Linear classifiers / univariate decision trees (decision stumps)</td>\n</tr>\n</tbody></table>\n<h1 id=\"neural-learning\"><a href=\"#neural-learning\">Neural Learning</a></h1>\n\n<p>Artificial Neural Networks (NN) are inspired by human nervous systems.\nNNs are composed of a large number of interconnected processing elements known as neurons.\nThey use supervised error correcting rules with back-propagation to learn a specific task.</p>\n<p>A single perceptron has multiple inputs $x_1, ..., x_n$ and a binary output, where the output $o$ can be modeled as</p>\n<p>$$\no(x_1, ..., x_n =\n\\begin{cases}\n  +1 &amp; \\text{if } w_0 + w_1x_1 + ... + x_0x_0 &gt; 0 \\\\\n  -1 &amp; \\text{otherwise}\n\\end{cases}\n$$</p>\n<p>Or in vector notation:</p>\n<p>$$\no(\\mathbf{x} =\n\\begin{cases}\n  +1 &amp; \\text{if } \\mathbf{w} \\cdot \\mathbf{x} &gt; 0\n  -1 &amp; \\text{otherwise}\n\\end{cases}\n$$</p>\n<p>As a result a perceptron is able to represent some useful functions which are linearly separable</p>\n<h2 id=\"perceptron-learning\">Perceptron Learning</h2>\n<p>Perceptron learning is simply an iterative weight-update scheme to find a good set of weights.</p>\n<p>$$w_{i+1} \\leftarrow w_i + \\Delta w_i$$</p>\n<p>where the weight update $\\Delta w_i$ depends only on misclassified examples and is modulated by a &quot;smoothing&quot; parameter $\\eta$ AKA learning rate.</p>\n<p>For example, the update rule can be written as</p>\n<p>$$w_{i+1} \\leftarrow w_i + \\eta y_ix_i$$</p>\n<p>where</p>\n<ul>\n<li>$w_t$ is the weight at iteration $t$</li>\n<li>$\\eta$ is the learning rate</li>\n<li>$y_i \\in \\{+1, 0, -1\\}$ acts to chance the sign (so if the current weights resulted in a missclassification, $y_i$ would reflect the update that needs to be applied to the weight)</li>\n<li>$x_i$ is the instance value</li>\n</ul>\n<p>Perception training will converge (under some mild assumptions) for linearly separable classification problems.</p>\n<p>However, with a relatively minor modification many perceptrons can be combined together to form one model</p>\n<ul>\n<li>Multilayer perceptrons, the classic &quot;neural network&quot;</li>\n</ul>\n<h2 id=\"gradient-descent-1\">Gradient Descent</h2>\n<p>Gradient descent / ascent is an optimisation algorithm that seeks to minimize / maximize a function.</p>\n<p>For a simple linear unit, where</p>\n<p>$$o = w_0 + w_1x_1 + ... + x_nx_n$$</p>\n<p>Let&#39;s learn $w_i$ that minimizes the squared error</p>\n<p>$$E[w] = \\frac{1}{2} \\sum_{d \\in D} (t_d - o_d)^2$$</p>\n<p>where $D$ is the set of training samples.</p>\n<p>The gradient is given by</p>\n<p>$$\\nabla E[w] = \\left[ \\frac{\\partial E}{\\partial w_0}, \\frac{\\partial E}{\\partial w_1}, ..., \\frac{\\partial E}{\\partial w_n} \\right]$$</p>\n<p>The gradient vector gives the direction of steepest increase in error $E$.\nNegative of the gradient, i.e. steepest decrease, is what we want.</p>\n<p>Training rule: $\\Delta \\mathbf{w} = -\\eta \\nabla E[\\mathbf{w}]$, i.e. $\\Delta w_i = - \\eta \\frac{\\partial E}{\\partial w_i}$.</p>\n<p>$$\n\\begin{align*}\n\\frac{\\partial E}{\\partial w_i}\n  &amp;= \\frac{\\partial}{\\partial w_i} \\frac{1}{2} \\sum_{d \\in D} (t_d - o_d)^2 \\\\\n  &amp;= \\frac{1}{2} \\sum_d \\frac{\\partial}{\\partial w_i} (t_d - o_d)^2 \\\\\n  &amp;= \\frac{1}{2} \\sum_d 2(t_d - o_d) \\frac{\\partial}{\\partial w_i}(t_d - o_d) \\\\\n  &amp;= \\sum_d (t_d - o_d) \\frac{\\partial}{\\partial w_i} (t_d - \\mathbf{w} \\cdot \\mathbf{x}_d) \\\\\n  &amp;= \\sum_d (t_d - o_d)(-x_{i,d})\n\\end{align*}\n$$</p>\n<p>Perceptron training rule guaranteed to succeed if:</p>\n<ul>\n<li>Training examples are linearly separable</li>\n<li>Sufficiently small learn rate $\\eta$</li>\n</ul>\n<p>Linear unit training rule uses gradient descent</p>\n<ul>\n<li>Guaranteed to converge to hypothesis with minimum squared error</li>\n<li>Given sufficiently small learning rate $\\eta$</li>\n<li>Even when training data contains noise and or not separable by $H$</li>\n</ul>\n<h2 id=\"stochastic-gradient-descent\">Stochastic Gradient Descent</h2>\n<p><strong>Batch mode</strong> Gradient Descent</p>\n<ul>\n<li>Do until satisfied<ul>\n<li>Compute the gradient $\\nabla E_D[\\mathbf{w}] = \\frac{1}{2} \\sum_{d \\in D} (t_d - o_d)^2$</li>\n<li>$\\mathbf{w} \\leftarrow \\mathbf{w} \\eta \\nabla E_D[\\mathbf{w}]$</li>\n</ul>\n</li>\n</ul>\n<p><strong>Stochastic (incremental) mode</strong> Gradient Descent</p>\n<ul>\n<li>Do until satisfied<ul>\n<li>For each training example $d \\in D$<ul>\n<li>Compute the gradient $\\nabla E_d[\\mathbf{w}] = \\frac{1}{2}(t_d - o_d)^2$</li>\n<li>$\\mathbf{w} \\leftarrow \\mathbf{w} - \\eta \\nabla E_d[\\mathbf{w}]$</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>SGD can approximate Batch Gradient Descent arbitrarily closely, if $\\eta$ made small enough</p>\n<ul>\n<li>Very useful for training large networks, or online learning from data streams</li>\n<li>Stochastic implies examples should be selected at random</li>\n</ul>\n<h2 id=\"multilayer-networks\">Multilayer Networks</h2>\n<p>Multilayer networks can represent arbitrary functions.\nIt typically consists of an input, hidden, and output layer, each fully connected to the next.\nThe weights determine the function computed.\nGiven an arbitrary number of hidden units, any boolean function can be computed with a single hidden layer.</p>\n<p>Properties of Artificial Neural Networks (ANN&#39;s):</p>\n<ul>\n<li>Many neuron-like threshold switching units</li>\n<li>Many weighted interconnections among units</li>\n<li>Highly parallel, distributed process</li>\n</ul>\n<p>Consider when</p>\n<ul>\n<li>Input is high-dimensional</li>\n<li>Output can be a vector of values or discrete, or real valued</li>\n<li>Form of target function is unknown</li>\n<li>Interpretability of result is not important</li>\n</ul>\n<p>Examples include speech recognition, image classification, and many others.</p>\n<h2 id=\"sigmoid-unit\">Sigmoid Unit</h2>\n<p>Same as a perceptron except step function is replaced by a nonlinear sigmoid function.</p>\n<p>$$\\sigma(x) = \\frac{1}{1+e^{-x}}$$\nNonlinearity makes it easy for the model to generalise or adapt with variety of data and to differentiate between the output.</p>\n<p>The sigmoid function is used because its derivative has a nice property</p>\n<p>$$\\frac{d \\sigma(x)}{dx} = \\sigma(x)(1 - \\sigma(x))$$</p>\n<p>We can derive gradient descent rules to train</p>\n<ul>\n<li>One sigmoid unit</li>\n<li>Multilayer networks of sigmoid units -&gt; Backpropagation</li>\n</ul>\n<p>Note: in practice, particularly for deep networks, sigmoid functions are less common than other non-linear activation functions that are easier to train, however sigmoids are mathematically convenient.</p>\n<p>To determine the error gradient of a sigmoid unit</p>\n<p>Start by assuming we want to minimize squared error over a set of training examples $D$.</p>\n<p>$$\n\\begin{align*}\n\\frac{\\partial E}{\\partial w_i}\n  &amp;= \\frac{\\partial}{\\partial w_i} \\frac{1}{2} \\sum_{d \\in D}(t_d - o_d)^2 \\\\\n  &amp;= \\frac{1}{2}  \\sum_{d \\in D} \\frac{\\partial}{\\partial w_i} (t_d - o_d)^2 \\\\\n  &amp;= \\frac{1}{2}  \\sum_{d \\in D} 2(t_d - o_d)\\frac{\\partial}{\\partial w_i} (t_d - o_d) \\\\\n  &amp;= \\sum_{d \\in D} 2(t_d - o_d) \\left( \\frac{\\partial o_d}{\\partial w_i} \\right) \\\\\n  &amp;= -\\sum_{d \\in D} 2(t_d - o_d) \\frac{\\partial o_d}{\\partial net_d} \\frac{\\partial net_d}{\\partial w_i}\\\\\n\\end{align*}\n$$</p>\n<p>We know:</p>\n<p>$$\\frac{\\partial o_d}{\\partial net_d} = \\frac{\\partial \\sigma(net_d)}{\\partial net_d} = o_d(1 - o_d)$$</p>\n<p>$$\\frac{\\partial net_d}{\\partial w_i} = \\frac{\\partial(\\mathbf{w} \\cdot \\mathbf{x})d)}{\\partial w_i} = x_{i,d}$$</p>\n<p>so:</p>\n<p>$$\\frac{\\partial E}{\\partial w_i} = - \\sum_{d \\in D}(t_d - o_d) o_d (1 - o_d) x_{i,d}$$</p>\n<h2 id=\"backpropagation-algorithm\">Backpropagation Algorithm</h2>\n<ul>\n<li>Initialize all weights to small random numbers</li>\n<li>Until satisified, do<ul>\n<li>For each training example, do<ul>\n<li>Input the training example to the network and compute the network outputs</li>\n<li>For each output unit $k$\n$$\\delta_k \\leftarrow o_k(1-o_k)(t_k-o_k)$$</li>\n<li>For each hidden unit $h$\n$$\\delta_h \\leftarrow o_h(1-o_h) \\sum_{k \\in outputs} w_{kh} \\delta_k$$</li>\n<li>Update each network weight $w_{ji}$\n$$w_{ji} \\leftarrow w_{ji} + \\Delta w_{ji}$$\nwhere\n$$\\Delta w_{ji} = \\eta \\delta_j x_{ji}$$</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>A solution for learning highly complex models:</p>\n<ul>\n<li>gradient descent over entire network weight vector</li>\n<li>Easily generalised to arbitrary directed graphs</li>\n<li>Can learn probabilistic models by maximising likelihood</li>\n</ul>\n<p>Minimises error over all training examples</p>\n<ul>\n<li>Training can take thousands of iterations -&gt; slow</li>\n<li>Using network after training is very fast</li>\n</ul>\n<p>Will converge to a local, not necessarily global, error minimum</p>\n<ul>\n<li>Might exist many such local minima, but in practice often works well</li>\n<li>Often include weight momentum $a$\n$$\\Delta w_{ji}(n) = \\eta \\delta_j x_{ji} + \\alpha \\Delta w_{ji} (n-1)$$</li>\n<li>Stochastic gradient descent using &quot;mini-batches&quot;</li>\n</ul>\n<p>Many ways to regularise network, making it less likely to overfit</p>\n<ul>\n<li>Add term to error that increases with magnitude of weight vector\n$$E(\\mathbf{w}) = \\frac{1}{2} \\sum_{d \\in D} \\sum_{k \\in outputs} (t_{kd} - o_{kd})^2 + \\gamma \\sum_{i,j} w_{ji}^2$$</li>\n<li>Other ways to penalise large weights, e.g. weight decay</li>\n<li>Using &quot;tied&quot; or shared set of weights, e.g. by setting all weights to their mean after computing the weight updates</li>\n</ul>\n<h2 id=\"neural-networks-for-classification\">Neural Networks for Classification</h2>\n<p>Minimizing square error does not work so well for classification.</p>\n<p>If we take the output $o(x)$ as the probability of the class $\\mathbf{x}$ being 1, the preferred loss function is the cross-entropy</p>\n<p>$$- \\sum_{d \\in D} t_d \\log o_d + (1 - t_d) \\log (1 - o_d)$$</p>\n<p>where:</p>\n<p>$t_d \\in \\{0,1\\}$ is the class label for training example $d$, and $o_d$ is the output of the sigmoid unit, interpreted as the probability of the class of training example $d$ being 1.</p>\n<p>To train sigmoid units for classification using this setup, one can use gradient descent and backpropagation algorithm - this will yield the maximum likelihood solution.</p>\n<h2 id=\"convolutional-neural-networks\">Convolutional Neural Networks</h2>\n<p>CNNs are very similar to regular Neural Networks</p>\n<ul>\n<li>Made up of neurons with learnable weights</li>\n</ul>\n<p>CNN architecture assumes that inputs are images</p>\n<ul>\n<li>So we have local features</li>\n<li>Which allows us to<ul>\n<li>encode certain properties in the architecture that makes the forward pass more efficient nad</li>\n<li>significantly reduces the number of parameters need for the network</li>\n</ul>\n</li>\n</ul>\n<p>The problem with regular NNs is that they do not scale well with dimensions.\nIn contrast, CNNS, consider 3D volumes of neurons and propose a parameter sharing scheme that minimises the number of params required by the network.</p>\n<p>CNN neurons are arranged in 3 dimensions: Width, Height, and Depth.\nNeurons in a layer are only connected to a small region of the layer before it (hence not fully connected).</p>\n<p>Main layers:</p>\n<ul>\n<li>Convolutional<ul>\n<li>Applies convolution operation (converts all pixels in its receptive field into a single value)</li>\n</ul>\n</li>\n<li>Pooling<ul>\n<li>the purpose is to reduce the spacial size of the representation to reduce the number of params and computation in the network and control overfitting</li>\n</ul>\n</li>\n<li>Rectified Linear Unit (ReLU)<ul>\n<li>Really an activation function ($f(x) = \\max(0,x)$) favoured over traditional activation functions like Sigmoid or Tanh<ul>\n<li>To accelerate the convergence of stochastic gradient descent</li>\n<li>Be computationally inexpensive compared to traditional ones</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Fully-connected<ul>\n<li>A fully connected layer to all activations</li>\n</ul>\n</li>\n<li>Drop-out<ul>\n<li>A layer where each forward pass, some neurons are randomly set to zero</li>\n<li>This reduces overfitting</li>\n</ul>\n</li>\n<li>Output layers</li>\n</ul>\n<h1 id=\"unsupervised-learning\"><a href=\"#unsupervised-learning\">Unsupervised Learning</a></h1>\n\n<p><strong>Supervised learning</strong></p>\n<ul>\n<li>Classes are known and need a &quot;definition&quot; in terms of the data</li>\n<li>Methods are known as:<ul>\n<li>classification</li>\n<li>discriminant analysis</li>\n<li>class prediction</li>\n<li>supervised pattern recognition</li>\n</ul>\n</li>\n</ul>\n<p><strong>Unsupervised learning</strong></p>\n<ul>\n<li>Classes are initially unknown and need to be discovered with their definitions from the data</li>\n<li>Methods are known as:<ul>\n<li>cluster analysis</li>\n<li>class discovery</li>\n<li>unsupervised pattern recognition</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"clustering\">Clustering</h2>\n<p>Clustering algorithms form two broad categories:</p>\n<ul>\n<li><strong>Partitioning</strong> methods<ul>\n<li>Typically require specification of the number of clusters</li>\n</ul>\n</li>\n<li><strong>Hierarchical</strong> methods<ul>\n<li>Hierarchical algorithms are either <strong>agglomerative</strong> i.e., bottom-up or <strong>divisive</strong> i.e., top-down</li>\n<li>In practice, hierarchical agglomerative methods are often used</li>\n<li>But more importantly to users, the dendrogram, or tree, which can be visualized in hierarchical methods</li>\n</ul>\n</li>\n</ul>\n<p>Let $X = \\{x_1, ..., x_m \\}$ be a set of instances</p>\n<p>Let $C = (C_1, ..., C_k)$ be a partition of $m$ elements into $k$ subsets.</p>\n<p>Each subset is called a cluster, and $C$ is called a clustering.</p>\n<h2 id=\"k-means-clustering\">K-means Clustering</h2>\n<p>Set value for $k$, th number of clusters</p>\n<p>Initialize: choose points for centres (means) of $k$ clusters (at random)</p>\n<p>Procedure:</p>\n<ol>\n<li>Assign each instance $x$ to the closest of the $k$ points to form $k$ clusters</li>\n<li>Re-assign the $k$ points to be the means of each of the $k$ clusters</li>\n<li>Repeat 1 and 2 until convergence to a reasonably stable clustering</li>\n</ol>\n<p>Despite weaknesses (suffering from outliers, or trapped in local minimum), $k$-means is still the most popular algorithm due to simplicity and efficiency.\nThere is no clear evidence that any other clustering algorithm performs better in general.</p>\n<h2 id=\"expectation-maximization\">Expectation Maximization</h2>\n<p>For $k = 2$, think of the full description of each instance as $y_i = (z_i, z_{i1}, z_{i2})$, where</p>\n<ul>\n<li>$z_{ij}$ is 1 if $x_i$ generated by $j^{th}$ Gaussian, otherwise zero</li>\n<li>$x_i$ is observable, from instance set $x_1, x_2, ..., x_m$</li>\n<li>$z_{ij}$ is unobservable</li>\n</ul>\n<p>Given:</p>\n<ul>\n<li>Instances from $X$ generated by mixture of $k$ Gaussian distributions</li>\n<li>Unknown means of the $k$ Gaussians</li>\n<li>Assuming identity covariance matrix</li>\n<li>Don&#39;t know whcih instance $x_i$ was generated by which Guassian</li>\n</ul>\n<p>Determine Maximum likelihood estimates of</p>\n<ul>\n<li>$\\text{means}(\\mu_1, ...,\\mu_k)$</li>\n</ul>\n<p><strong>Initialize:</strong> Pick random initial $h = (\\mu_1, ..., \\mu_k$</p>\n<p><strong>Iterate:</strong>\n<strong>E step:</strong> Calculate expected value $E[z_{ij}$ of each hidden variable $z_{ij}$, assuming current hypothesis $h = (\\mu_1, ..., \\mu_k)$ holds:</p>\n<p>$$\n\\begin{align*}\nE[z_{ij}]\n  &amp;= \\frac{P(x=x_i|\\mu=\\mu_j)}{\\sum_{n=1}^k p(x=x_i|\\mu=\\mu_n)} \\\\\n  &amp;= \\frac{\\exp \\left( - \\frac{1}{2 \\sigma^2} (x_i - \\mu_j)^2 \\right)}{\\sum_{n=1}^k \\exp \\left( - \\frac{1}{2 \\sigma^2} (x_i - \\mu_n)^2 \\right)}\n\\end{align*}\n$$</p>\n<p><strong>M step:</strong> Calculate new maximum likelihood hypthesis $h&#39; = (\\mu_1&#39;, ..., \\mu_k&#39;)$ assuming value taken on each hidden variable $z_{ij}$ is the expected value $E[z_{ij}]$ calculated before.\nReplace $h = (\\mu_1, ..., \\mu_k)$ by $h&#39; = (\\mu_1&#39;, ..., \\mu_k&#39;)$.</p>\n<p>$$\\mu_j \\leftarrow \\frac{\\sum_{i=1}^m E[z_{ij}] x_i}{\\sum_{i=1}^m E[z_{ij}]}$$</p>\n<p>Converges to local maximum likelihood $h$ and provides estimates of hidden variables $z_{ij}$.</p>\n<p>In fact, local maximum in $E[\\ln P(Y|h)]$</p>\n<ul>\n<li>$Y$ is complete (observable plus unobservable variables) data</li>\n<li>Expected value taken over possible values of unobserved variables in $Y$</li>\n</ul>\n<h2 id=\"hierarchical-clustering\">Hierarchical Clustering</h2>\n<p><strong>Bottom up:</strong> at each step join two closest clusters (starting with single-instance clusters)</p>\n<ul>\n<li>Design decision: distance between clusters E.g., two closest instances in clusters vs distance between means</li>\n</ul>\n<p><strong>Top down:</strong> find two clusters and then proceed recursively for the two subsets</p>\n<ul>\n<li>Can be very fast</li>\n</ul>\n<h3 id=\"determining-number-of-clusters\">Determining number of clusters</h3>\n<p>Elbow method:</p>\n<ul>\n<li>Measure within-cluster dispersion (sum of squared distances from each point to cluster centroid)</li>\n<li>Compute this for various $k$ choices</li>\n<li>Choose the $k$ that doesn&#39;t improve the dispersion that much</li>\n</ul>\n<p>Gap statistics:</p>\n<ul>\n<li>Cluster observed data and compute the corresponding total with-cluster variation $W_k$</li>\n<li>Generate $b$ reference data sets with random uniform distribution.\nCluster each of these reference data sets and compute the corresponding total within-cluster variation $W_{kb}$</li>\n<li>Compute the estimated gap statistic as the deviation of the observed $W_k$ value from its expected value $W_{kb} : Gap(k) = \\frac{1}{B} \\sum_{b} \\log(W_{kb}) - \\log(W_k)$.\nCompute also the std dev of the statistics</li>\n<li>Choose $k$ as the smallest value s.t. the gap statistic is within 1 std dev of the gap at $k + 1$\n$$Gap(k) \\geq Gap(k + 1) - s_{k+1}$$</li>\n</ul>\n<h2 id=\"principal-component-analysis-pca\">Principal Component Analysis (PCA)</h2>\n<p>Key idea: look for features in a transformed space so that each dimension in the new space captures the most variation in the original data when it is projected onto that dimension.</p>\n<ol>\n<li>Take the data as an $m \\times n$ matrix $X$</li>\n<li>&quot;centre&quot; the data by subtracting the mean of each column</li>\n<li>Construct covariance matrix $C$ from centred matrix</li>\n<li>Compute eigenvector matrix $V$ (rotation) and eigenvalue matrix $S$ (scaling) such that $V^{-1}CV = S$ and $S$ is a diagonal $n \\times n$ matrix</li>\n<li>Sort columns of $S$ in decreasing order (decreasing variance) and their corresponding eigenvectors</li>\n<li>Remove columns of $S$ and $V$ that the eigenvalues are below some minimum threshold</li>\n<li>Transform the original data using the remaining eigenvectors</li>\n</ol>\n<ul>\n<li>PCA complexity is cubic in number of original features (not feasible for high-dimensional datasets)</li>\n<li>Alternatively can use random projections to approximate the sort of projection found by PCA</li>\n</ul>\n<h2 id=\"semi-supervised-learning\">Semi-supervised Learning</h2>\n<ol>\n<li>Learn initial classifier using labelled set</li>\n<li>Apply classifier to unlabelled set</li>\n<li>The most confident predictions of each classifier on the unlabelled data are retained</li>\n<li>Learn new classifier from now-labelled data</li>\n<li>Repeat until convergence</li>\n</ol>\n<h2 id=\"self-training-algorithm\">Self-training algorithm</h2>\n<p><strong>Given:</strong> labelled data $(x,y)$ and unlabelled data $(x)$</p>\n<p><strong>Repeat:</strong></p>\n<ul>\n<li>Train classifier $H$ from labelled data using supervised learning</li>\n<li>Label unlabelled data using classifier $h$</li>\n</ul>\n<p><strong>Assumes:</strong> classifications by $h$ will tend to be correct (especially high probability ones)</p>\n<h2 id=\"co-training\">Co-Training</h2>\n<p><strong>Key idea:</strong> two views of an instance, $f_1$ and $f_2$</p>\n<ul>\n<li>assume $f_1$ and $f_2$ independent and compatible</li>\n<li>If we hve a good attribute set, leverage similarity between attribute values in each view, assuming they predict the class, to classify the unlabelled data</li>\n</ul>\n<p>Multi-view learning</p>\n<ul>\n<li>Given two (or more) perspectives on data, e.g., different attribute sets</li>\n<li>Train separate models for each perspective on small set of labelled data</li>\n<li>Use models to label a subset of the unlabelled data</li>\n<li>Repeat until no more unlabelled examples</li>\n</ul>\n<h1 id=\"learning-theory\"><a href=\"#learning-theory\">Learning Theory</a></h1>\n\n<h2 id=\"computational-learning-theory\">Computational Learning Theory</h2>\n<p><strong>Machine learning:</strong> Have a computer solve problems by learning from data\nrather than being explicitly programmed.</p>\n<ul>\n<li>Regression</li>\n<li>Classification</li>\n<li>Clustering</li>\n<li>Ranking</li>\n<li>Reinforcement Learning</li>\n<li>...</li>\n</ul>\n<p><strong>Inductive learning:</strong> learning from examples and all machine learning\nalgorithms are a kind of inductive learning and there are some\nquestions that we are interested to be able to answer in such\nframework:</p>\n<ul>\n<li>Probability of successful learning</li>\n<li>Number of training examples</li>\n<li>Complexity of hypothesis space</li>\n<li>Time complexity of learning algorithm</li>\n<li>Accuracy to which target concept is approximated</li>\n<li>Manner in which training examples presented</li>\n<li>...</li>\n</ul>\n<p>Instead of focusing on particular algorithms, learning theory aims to characterize classes of algorithms.</p>\n<h2 id=\"probably-approximately-correct\">Probably Approximately Correct</h2>\n<p>Probably Approximately Correct (PAC) is a framework for mathematical analysis of learning which was proposed by Valiant in 1984.</p>\n<p>The framework of PAC learning can be used to address questions such as:</p>\n<ul>\n<li>How many training examples?</li>\n<li>How much computational effort required?</li>\n<li>How complex a hypothesis class needed?</li>\n<li>How to quantify hypothesis complexity?</li>\n<li>How many mistakes will be made?</li>\n</ul>\n<h3 id=\"sample-complexity\">Sample Complexity</h3>\n<p><strong>Given:</strong></p>\n<ul>\n<li>set of instances $X$</li>\n<li>set of hypotheses $H$</li>\n<li>set of possible target concepts $C$</li>\n<li>training instances generated by a fixed, unknown probability distribution $\\mathcal{D}$ over $X$</li>\n</ul>\n<p>Learner observes a sequence $D$ of training examples of form $(x,c(x))$, for some target concept $c \\in C$</p>\n<ul>\n<li>Instances $x$ are drawn from distribution $\\mathcal{D}$</li>\n<li>teacher provides target value $c(x)$ for each $x$</li>\n</ul>\n<p>Learner must output a hypothesis $h$ estimating $c$</p>\n<ul>\n<li>$h$ is evaluated by its performance on subsequent instances drawn according to $\\mathcal{D}$</li>\n</ul>\n<p>Note: randomly drawn instances</p>\n<p><strong>True Error of a Hypothesis</strong>: The <strong>true error</strong> (denoted $error_{\\mathcal{D}}(h)$) of hypothesis $h$ with respect to target concept $c$ and distribution $\\mathcal{D}$ is the probability that $h$ will misclassify an instance drawn at random according to $\\mathcal{D}$.</p>\n<p>$$error_{\\mathcal{D}}(h) \\equiv \\text{Pr}_{X \\in \\mathcal{D}} [c(x) \\neq h(x)]$$</p>\n","metadata":{"title":"COMP9417","description":"Machine Learning and Data Mining","date":"2022-05-02","mathjax":true,"hljs":true},"toc":[{"id":"statistical-techniques-for-data-analysis","title":"Statistical Techniques for Data Analysis"},{"id":"regression","title":"Regression"},{"id":"classification","title":"Classification"},{"id":"tree-learning","title":"Tree Learning"},{"id":"kernel-methods","title":"Kernel Methods"},{"id":"ensemble-learning","title":"Ensemble Learning"},{"id":"neural-learning","title":"Neural Learning"},{"id":"unsupervised-learning","title":"Unsupervised Learning"},{"id":"learning-theory","title":"Learning Theory"}]},"__N_SSG":true}